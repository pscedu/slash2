Only in next: git-find.sh
Only in next: KNOWN-ISSUES.txt
diff -dru -x .git develop/mk/defs.mk next/mk/defs.mk
--- develop/mk/defs.mk	2018-03-27 11:21:55.952605342 -0400
+++ next/mk/defs.mk	2018-03-27 11:22:34.249732603 -0400
@@ -47,10 +47,7 @@
 			echo lex;					\
 		fi)
 
-# The following can/should be overridden with file local.mk in the same directory.
- 
 INST_BASE?=	/local
-
 INST_BINDIR?=	${INST_BASE}/bin
 INST_SBINDIR?=	${INST_BASE}/sbin
 INST_LIBDIR?=	${INST_BASE}/lib
diff -dru -x .git develop/mk/main.mk next/mk/main.mk
--- develop/mk/main.mk	2018-03-27 11:21:55.953605293 -0400
+++ next/mk/main.mk	2018-03-27 11:22:34.250732554 -0400
@@ -1,7 +1,6 @@
 # $Id$
 # %ISC_START_LICENSE%
 # ---------------------------------------------------------------------
-# Copyright 2015-2016, Google, Inc.
 # Copyright 2006-2018, Pittsburgh Supercomputing Center
 # All rights reserved.
 #
diff -dru -x .git develop/pfl/fuse.c next/pfl/fuse.c
--- develop/pfl/fuse.c	2018-03-27 11:21:56.020602016 -0400
+++ next/pfl/fuse.c	2018-03-27 11:22:34.316729328 -0400
@@ -238,7 +238,7 @@
 	 * This should never fail (famous last words) since the fd
 	 * is only closed in fuse_listener_exit()
 	 *
-	 * Receive fuse_fs_info_t from pscfs_fuse_newfs().
+	 * Receive fuse_fs_info_t() from pscfs_fuse_newfs().
 	 */
 	psc_assert(fd_read_loop(pflfs_fds[0].fd, &fs,
 	    sizeof(fuse_fs_info_t)) == 0);
@@ -468,6 +468,27 @@
 }
 
 void
+pscfs_ctlparam_entry_timeout_get(char buf[PCP_VALUE_MAX])
+{
+	snprintf(buf, PCP_VALUE_MAX, "%g", pscfs_entry_timeout);
+}
+
+int
+pscfs_ctlparam_entry_timeout_set(const char *s)
+{
+	double val;
+	char *endp;
+
+	endp = NULL;
+	val = strtod(s, &endp);
+	if (val < 0. || val > 60. ||
+	    endp == s || *endp != '\0')
+		return (-1);
+	pscfs_entry_timeout = val;
+	return (0);
+}
+
+void
 pscfs_ctlparam_attr_timeout_get(char buf[PCP_VALUE_MAX])
 {
 	snprintf(buf, PCP_VALUE_MAX, "%g", pscfs_attr_timeout);
@@ -556,6 +577,14 @@
 	    pscfs_ctlparam_fuse_debug_get,
 	    pscfs_ctlparam_fuse_debug_set);
 #endif
+	psc_ctlparam_register_simple("fuse.version",
+	    pscfs_ctlparam_fuse_version_get, NULL);
+	psc_ctlparam_register_simple("pscfs.entry_timeout",
+	    pscfs_ctlparam_entry_timeout_get,
+	    pscfs_ctlparam_entry_timeout_set);
+	psc_ctlparam_register_simple("pscfs.attr_timeout",
+	    pscfs_ctlparam_attr_timeout_get,
+	    pscfs_ctlparam_attr_timeout_set);
 #endif
 
 	thrv = PSCALLOC(sizeof(*thrv) * nthr);
diff -dru -x .git develop/pfl/log.c next/pfl/log.c
--- develop/pfl/log.c	2018-03-27 11:21:56.034601332 -0400
+++ next/pfl/log.c	2018-03-27 11:22:34.330728642 -0400
@@ -139,18 +139,12 @@
 		warn("log snprintf rc = %d", rc);
 		return;
 	}
-	/*
-	 * Rename the current log file to keep a copy.
-	 */
 	rc = rename(logfn, newfn);
 	if (rc < 0) {
 		warn("log rename rc = %d", rc);
 		return;
 	}
 
-	/*
-	 * Reopen the log file to accept new contents.
-	 */
 	if (freopen(logfn, "w", stderr) == NULL) {
 		warn("log freopen %s, rc = %d", logfn, rc);
 		return;
diff -dru -x .git develop/pfl/rpc_intrfc.h next/pfl/rpc_intrfc.h
--- develop/pfl/rpc_intrfc.h	2018-03-27 11:21:56.068599670 -0400
+++ next/pfl/rpc_intrfc.h	2018-03-27 11:22:34.364726980 -0400
@@ -26,12 +26,8 @@
 #define _PFL_RPC_INTRFC_H_
 
 /* 
- * It used to be 64, however, we use it at various 
- * places to define the size of a log buffer. See
- * pscrpc_check_status() for an example.
- *
- * What about LNET_NIDSTR_SIZE?
- *
+ * used to be 64, however, we use it at various 
+ * places to define a log buffer.
  */ 
 #define PSCRPC_NIDSTR_SIZE	256
 
diff -dru -x .git develop/pfl/service.c next/pfl/service.c
--- develop/pfl/service.c	2018-03-27 11:21:56.074599376 -0400
+++ next/pfl/service.c	2018-03-27 11:22:34.369726735 -0400
@@ -611,7 +611,6 @@
 		rqbd = pscrpc_alloc_rqbd(svc);
 
 		if (rqbd == NULL) {
-			/* 01/29/2018: Crash here on signal 7 */
 			CERROR("%s: Can't allocate request buffer",
 				svc->srv_name);
 			return (-ENOMEM);
@@ -732,7 +731,6 @@
 			 svc->srv_n_active_reqs < (svc->srv_nthreads - 1)))
 		);
 #endif
-		/* 01/22/2018: Program terminated with signal 7, Bus error. */
 		(void)pscrpc_svr_wait_event(&svc->srv_waitq,
 		    pscrpcthr_waitevent(thr, svc) || !prt->prt_alive,
 		    &lwi, NULL);
diff -dru -x .git develop/pfl/utils/daemon/pfl_daemon.sh next/pfl/utils/daemon/pfl_daemon.sh
--- develop/pfl/utils/daemon/pfl_daemon.sh	2018-03-27 11:21:56.162595074 -0400
+++ next/pfl/utils/daemon/pfl_daemon.sh	2018-03-27 11:22:34.456722482 -0400
@@ -2,7 +2,6 @@
 # $Id$
 # %ISC_START_LICENSE%
 # ---------------------------------------------------------------------
-# Copyright 2015-2016, Google, Inc.
 # Copyright 2013-2018, Pittsburgh Supercomputing Center
 # All rights reserved.
 #
@@ -263,7 +262,7 @@
 			# slash2 code base. It should be the last submit to
 			# to be accurate. Use + to allow lazy update.
 			#
-			echo slash2 version is 45194+
+			echo slash2 version is 29+
 			echo core file is $base/$coredir/$cf
 			echo binary is $base/$coredir/$prog.$id
 			
diff -dru -x .git develop/slash2/doc/new-mds.txt next/slash2/doc/new-mds.txt
--- develop/slash2/doc/new-mds.txt	2018-03-27 11:22:08.568988399 -0400
+++ next/slash2/doc/new-mds.txt	2018-03-27 11:22:34.515719597 -0400
@@ -72,9 +72,6 @@
 	* Right now, the state of bmap take 3 bits.  We can make it 4 bits so that (1)
 	  allow future growth (2) easier to implement and debug.
 
-
-	* Need to track per-bmap disk usage for future quota enforcement as well as du.
-
 Obstacle:
 
 	* This is a on-disk format change.
Only in develop/slash2/doc: revert-diff-01-09-2018.txt
diff -dru -x .git develop/slash2/include/bmap.h next/slash2/include/bmap.h
--- develop/slash2/include/bmap.h	2018-03-27 11:22:08.796977319 -0400
+++ next/slash2/include/bmap.h	2018-03-27 11:22:34.541718325 -0400
@@ -2,8 +2,7 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
- * Copyright 2006-2016, Pittsburgh Supercomputing Center
+ * Copyright 2006-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -137,7 +136,7 @@
 #define BMAPF_DIO		(1 <<  4)	/* direct I/O; no client caching allowed */
 #define BMAPF_TOFREE		(1 <<  5)	/* refcnt dropped to zero, removing */
 #define BMAPF_DISCARD		(1 <<  6)	/* discard bmap asap */
-#define BMAPF_MODECHNG		(1 <<  7)	/* op mode changing (i.e., READ -> WRITE) */
+#define BMAPF_MODECHNG		(1 <<  7)	/* op mode changing (e.g. READ -> WRITE) */
 #define BMAPF_WAITERS		(1 <<  8)	/* has bcm_fcmh waiters */
 #define BMAPF_BUSY		(1 <<  9)	/* temporary processing lock */
 #define _BMAPF_SHIFT		(1 <<  10)
@@ -396,7 +395,6 @@
 
 struct bmap_ops {
 	void	(*bmo_init_privatef)(struct bmap *);
-	int	(*bmo_reapf)(void);			/* not used for now */
 	int	(*bmo_retrievef)(struct bmap *, int);
 	int	(*bmo_mode_chngf)(struct bmap *, enum rw, int);
 	void	(*bmo_final_cleanupf)(struct bmap *);
diff -dru -x .git develop/slash2/include/ctlsvr.h next/slash2/include/ctlsvr.h
--- develop/slash2/include/ctlsvr.h	2018-03-27 11:22:08.799977130 -0400
+++ next/slash2/include/ctlsvr.h	2018-03-27 11:22:34.544718178 -0400
@@ -2,8 +2,7 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015, Google, Inc.
- * Copyright (c) 2009-2015, Pittsburgh Supercomputing Center (PSC).
+ * Copyright 2009-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -45,7 +44,6 @@
 
 void slctlparam_uptime_get(char *);
 void slctlparam_version_get(char *);
-void slctlparam_rpc_version_get(char *);
 void slctlparam_logrotate_get(char *);
 int  slctlparam_logrotate_set(const char *);
 
diff -dru -x .git develop/slash2/include/fidcache.h next/slash2/include/fidcache.h
--- develop/slash2/include/fidcache.h	2018-03-27 11:22:08.800977072 -0400
+++ next/slash2/include/fidcache.h	2018-03-27 11:22:34.546718080 -0400
@@ -2,8 +2,7 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015, Google, Inc.
- * Copyright 2006-2016, Pittsburgh Supercomputing Center
+ * Copyright 2006-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -218,8 +217,7 @@
 #define FCMH_OPCNT_DIRCACHE		10	/* CLI: async dircache */
 #define FCMH_OPCNT_SYNC_AHEAD		11	/* IOD: sync ahead */
 #define FCMH_OPCNT_UPDATE		12	/* IOD: update file */
-#define FCMH_OPCNT_CALLBACK		13
-#define FCMH_OPCNT_MAXTYPE		14
+#define FCMH_OPCNT_MAXTYPE		13
 
 void	fidc_init(int);
 void	fidc_destroy(void);
diff -dru -x .git develop/slash2/include/slashrpc.h next/slash2/include/slashrpc.h
--- develop/slash2/include/slashrpc.h	2018-03-27 11:22:08.803976897 -0400
+++ next/slash2/include/slashrpc.h	2018-03-27 11:22:34.548717982 -0400
@@ -2,8 +2,7 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
- * Copyright 2006-2016, Pittsburgh Supercomputing Center
+ * Copyright 2006-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -47,7 +46,7 @@
  * can have different versions. However, to avoid hassle in terms 
  * of maintainence and administration. Let us use one version.
  */
-#define	SL_RPC_VERSION		3
+#define	SL_RPC_VERSION		2
 
 /* RPC channel to MDS from CLI. */
 #define SRMC_REQ_PORTAL		10
@@ -196,8 +195,6 @@
 	SRMT_BATCH_RP,				/* 50: async batch reply */
 	SRMT_CTL,				/* 51: generic control */
 
-	SRMT_FILECB,				/* 52: file callback */
-
 	SRMT_TOTAL
 };
 
@@ -244,14 +241,6 @@
 	uint64_t		opv;		/* value */
 };
 
-struct srm_filecb_req {
-	struct sl_fidgen	fg;		/* file */
-	uint32_t		flags;		/* semantics */
-	 int32_t		_pad;
-} __packed;
-
-#define srm_filecb_rep		srm_generic_rep
-
 #define SRMCTL_OPT_HEALTH	0
 
 /* ---------------------- BEGIN ENCAPSULATED MESSAGES ----------------------- */
@@ -808,7 +797,7 @@
 	struct srt_stat		cattr;		/* attrs of new file */
 	struct srt_stat		pattr;		/* parent dir attributes */
 	 int32_t		rc;		/* 0 for success or slerrno */
-	int32_t			lease;
+	 int32_t		_pad;
 
 	/* parameters for fetching first bmap */
 	uint32_t		rc2;		/* (for GETBMAP) 0 or slerrno */
@@ -819,15 +808,13 @@
 struct srm_getattr_req {
 	struct sl_fidgen	fg;
 	sl_ios_id_t		iosid;
-	 int32_t		lease;
+	 int32_t		_pad;
 } __packed;
 
 struct srm_getattr_rep {
 	struct srt_stat		attr;
 	 uint32_t		xattrsize;
 	 int32_t		rc;
-	 int32_t		lease;	
-	 int32_t		_pad;
 } __packed;
 
 struct srm_getattr2_rep {
@@ -835,8 +822,6 @@
 	struct srt_stat		pattr;		/* parent dir */
 	 int32_t		rc;
 	 int32_t		_pad;
-	 int32_t		clease;
-	 int32_t		please;
 } __packed;
 
 struct srm_io_req {
@@ -924,8 +909,7 @@
 	uint32_t		eof:1;		/* flag: directory read EOF */
 	uint32_t		nents:31;	/* #dirents returned */
 	 int32_t		rc;
-	 int32_t		lease;
-	unsigned char		ents[820];
+	unsigned char		ents[824];
 /* XXX ents should be in a portable format, not fuse_dirent */
 /* XXX ents is (fuse_dirent * N, 64-bit align, srt_readdir_ent * N) */
 } __packed;
@@ -961,9 +945,7 @@
 	struct srt_stat		srr_cattr;	/* child node */
 	struct srt_stat		srr_clattr;	/* clobbered node */
 	 int32_t		rc;
-	 int32_t		olease;
-	 int32_t		nlease;
-	 int32_t		clease;
+	 int32_t		_pad;
 } __packed;
 
 struct srm_replrq_req {
@@ -1007,7 +989,7 @@
 	struct sl_fidgen	pfg;		/* parent dir */
 	char			name[SL_NAME_MAX + 1];
 	uint32_t		linklen;	/* NUL not transmitted */
-	 int32_t		lease;	
+	 int32_t		_pad;
 /* link path name is in bulk */
 } __packed;
 
@@ -1023,8 +1005,6 @@
 	struct srt_stat		pattr;		/* parent dir */
 	 int32_t		valid;		/* child attr valid */
 	 int32_t		rc;
-	 int32_t		lease;		/* if valid is set */
-	 int32_t		_pad;
 } __packed;
 
 struct srm_listxattr_req {
diff -dru -x .git develop/slash2/Makefile next/slash2/Makefile
--- develop/slash2/Makefile	2018-03-27 11:22:08.549989329 -0400
+++ next/slash2/Makefile	2018-03-27 11:22:34.497720477 -0400
@@ -1,8 +1,7 @@
 # $Id$
 # %GPL_START_LICENSE%
 # ---------------------------------------------------------------------
-# Copyright 2015, Google, Inc.
-# Copyright (c) 2007-2015, Pittsburgh Supercomputing Center (PSC).
+# Copyright 2007-2018, Pittsburgh Supercomputing Center
 # All rights reserved.
 #
 # This program is free software; you can redistribute it and/or modify
diff -dru -x .git develop/slash2/mount_slash/bflush.c next/slash2/mount_slash/bflush.c
--- develop/slash2/mount_slash/bflush.c	2018-03-27 11:22:08.813976416 -0400
+++ next/slash2/mount_slash/bflush.c	2018-03-27 11:22:34.559717445 -0400
@@ -2,7 +2,6 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
  * Copyright 2008-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
@@ -303,7 +302,7 @@
 /*
  * Called in error contexts where the biorq must be rescheduled by
  * putting it back to the new request queue.  Typically this is from a
- * write RPC cb.
+ * write RPC callback.
  */
 void
 bmap_flush_resched(struct bmpc_ioreq *r, int rc)
@@ -325,10 +324,8 @@
 
 	BIORQ_LOCK(r);
 
-	if (rc == -EAGAIN)
-		goto requeue;
-
-	if (rc == -ENOSPC || r->biorq_retries >= SL_MAX_BMAPFLSH_RETRIES ||
+	if ((b->bcm_flags & BMAPF_DISCARD) ||
+	    rc == -ENOSPC || r->biorq_retries >= SL_MAX_BMAPFLSH_RETRIES ||
 	    ((r->biorq_flags & BIORQ_EXPIRE) && 
 	     (r->biorq_retries >= msl_max_retries * 32))) {
 
@@ -337,12 +334,22 @@
 			bci->bci_flush_rc = rc;
 		BMAP_ULOCK(r->biorq_bmap);
 
-		OPSTAT_INCR("msl.bmap-flush-maxretry");
+		if (b->bcm_flags & BMAPF_DISCARD)
+			OPSTAT_INCR("msl.bmap-flush-discard");
+	     	else if (rc == -ENOSPC)
+			OPSTAT_INCR("msl.bmap-flush-enospc");
+		else
+			OPSTAT_INCR("msl.bmap-flush-maxretry");
 		msl_bmpces_fail(r, rc);
 		msl_biorq_release(r);
 		return;
 	}
 
+	/*
+ 	 * We might BMAP_ULOCK so don't clear it earlier.
+ 	 */
+	if (rc == -EAGAIN)
+		goto requeue;
 
 	if (r->biorq_last_sliod == bmap_2_ios(r->biorq_bmap) ||
 	    r->biorq_last_sliod == IOS_ID_ANY)
@@ -445,10 +452,11 @@
 		 * one RPC.  So the callback handler won't race with us.
 		 */
 		r->biorq_last_sliod = bmap_2_ios(b);
-
+	
 		psc_assert(r->biorq_flags & BIORQ_ONTREE);
 		r->biorq_flags &= ~BIORQ_ONTREE;
 
+		/* XXX not using rwlock here */
 		PSC_RB_XREMOVE(bmpc_biorq_tree, &bmpc->bmpc_biorqs, r);
 	}
 	BMAP_ULOCK(b);
@@ -763,11 +771,17 @@
 		psc_assert(b->bcm_flags & BMAPF_FLUSHQ);
 
 		if ((b->bcm_flags & BMAPF_SCHED) ||
-		    (b->bcm_flags & BMAPF_DISCARD) ||
 		    (b->bcm_flags & BMAPF_REASSIGNREQ)) {
 			BMAP_ULOCK(b);
 			continue;
 		}
+		if (b->bcm_flags & BMAPF_DISCARD) {
+			b->bcm_flags |= BMAPF_SCHED;
+			psc_dynarray_add(bmaps, b);
+			bmap_op_start_type(b, BMAP_OPCNT_FLUSH);
+			goto add;
+		}
+
 		m = libsl_ios2resm(bmap_2_ios(b));
 		rc = msl_resm_throttle_yield(m);
 		if (!rc && bmap_flushable(b)) {
@@ -775,8 +789,8 @@
 			psc_dynarray_add(bmaps, b);
 			bmap_op_start_type(b, BMAP_OPCNT_FLUSH);
 		}
+ add:
 		BMAP_ULOCK(b);
-
 		if (psc_dynarray_len(bmaps) >= msl_ios_max_inflight_rpcs)
 			break;
 	}
@@ -787,6 +801,12 @@
 		bmpc = bmap_2_bmpc(b);
 
 		BMAP_LOCK(b);
+		if (b->bcm_flags & BMAPF_DISCARD) {
+			OPSTAT_INCR("msl.bmap-flush-discard");
+			bmpc_biorqs_destroy_locked(b);
+			goto next;
+		}
+
 		if (!bmap_flushable(b)) {
 			OPSTAT_INCR("msl.bmap-flush-bail");
 			goto next;
@@ -807,9 +827,9 @@
 			if (!rc)
 				didwork = 1;
 		}
+		BMAP_LOCK(b);
 		psc_dynarray_reset(reqs);
 
-		BMAP_LOCK(b);
  next:
 		b->bcm_flags &= ~BMAPF_SCHED;
 		bmap_op_done_type(b, BMAP_OPCNT_FLUSH);
diff -dru -x .git develop/slash2/mount_slash/bmap_cli.c next/slash2/mount_slash/bmap_cli.c
--- develop/slash2/mount_slash/bmap_cli.c	2018-03-27 11:22:08.815976326 -0400
+++ next/slash2/mount_slash/bmap_cli.c	2018-03-27 11:22:34.560717396 -0400
@@ -2,7 +2,6 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
  * Copyright 2008-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
@@ -168,7 +167,6 @@
 	psc_assert(sbd->sbd_fg.fg_fid == fcmh_2_fid(b->bcm_fcmh));
 
 	if (b->bcm_flags & BMAPF_WR)
-		/* XXX hit this on 01/18/2018 */
 		psc_assert(sbd->sbd_ios != IOS_ID_ANY);
 
 	if (msl_force_dio)
@@ -395,6 +393,7 @@
 	struct slrpc_cservice *csvc = args->pointer_arg[MSL_CBARG_CSVC];
 	struct bmap *b = args->pointer_arg[MSL_CBARG_BMAP];
 	struct srm_leasebmapext_rep *mp;
+	struct bmap_cli_info *bci = bmap_2_bci(b);
 
 	int rc;
 
@@ -419,7 +418,7 @@
 	if (!rc) {
 		OPSTAT_INCR("msl.extend-success-nonblocking");
 		msl_bmap_stash_lease(b, &mp->sbd, "extend");
-		msl_bmap_reap_init(b);
+		lc_move2tail(&msl_bmaptimeoutq, bci);
 		OPSTAT_INCR("msl.bmap-extend-cb-ok");
 	} else {
 		msl_bmap_cache_rls(b);
@@ -545,10 +544,8 @@
 	}
 
 	BMAP_LOCK(b);
-	if (!rc) {
-		msl_bmap_stash_lease(b, &mp->sbd, "extend");
-		msl_bmap_reap_init(b);
-	}
+	if (!rc)
+		 msl_bmap_stash_lease(b, &mp->sbd, "extend");
 	b->bcm_flags &= ~(BMAPF_LEASEEXTREQ | BMAPF_LOADING);
 	DEBUG_BMAP(rc ? PLL_ERROR : PLL_DIAG, b,
 	    "lease extension req (rc=%d) (secs=%ld)", rc, secs);
@@ -577,7 +574,6 @@
 	/* ignore all errors for this background operation */
 	if (!rc) {
 		msl_bmap_stash_lease(b, &mp->sbd, "modechange");
-		msl_bmap_reap_init(b);
 		psc_assert((b->bcm_flags & BMAP_RW_MASK) == BMAPF_RD);
 		b->bcm_flags = (b->bcm_flags & ~BMAPF_RD) | BMAPF_WR;
 		r = libsl_id2res(bmap_2_sbd(b)->sbd_ios);
@@ -710,7 +706,6 @@
 
 		BMAP_LOCK(b);
 		msl_bmap_stash_lease(b, &mp->sbd, "modechange");
-		msl_bmap_reap_init(b);
 		psc_assert((b->bcm_flags & BMAP_RW_MASK) == BMAPF_RD);
 		b->bcm_flags = (b->bcm_flags & ~BMAPF_RD) | BMAPF_WR;
 		r = libsl_id2res(bmap_2_sbd(b)->sbd_ios);
@@ -755,10 +750,8 @@
 	psc_assert(b->bcm_flags & BMAPF_REASSIGNREQ);
 
 	SL_GET_RQ_STATUS(csvc, rq, mp, rc);
-	if (!rc) {
+	if (!rc)
 		msl_bmap_stash_lease(b, &mp->sbd, "reassign");
-		msl_bmap_reap_init(b);
-	}
 
 	b->bcm_flags &= ~BMAPF_REASSIGNREQ;
 	bmap_op_done_type(b, BMAP_OPCNT_ASYNC);
@@ -917,6 +910,8 @@
 
 		if (!r)
 			psc_fatalx("Invalid IOS %x", sbd->sbd_ios);
+		psc_assert(b->bcm_flags & BMAPF_WR);
+
 		if (r->res_type == SLREST_ARCHIVAL_FS)
 			b->bcm_flags |= BMAPF_DIO;
 	}
@@ -1070,6 +1065,7 @@
 				BMAP_ULOCK(b);
 				continue;
 			}
+
 			if (b->bcm_flags & BMAPF_DISCARD) {
 				BMAP_ULOCK(b);
 				continue;
@@ -1435,7 +1431,6 @@
 
 struct bmap_ops sl_bmap_ops = {
 	msl_bmap_init,			/* bmo_init_privatef() */
-	NULL,				/* bmo_reapf() */
 	msl_bmap_retrieve,		/* bmo_retrievef() */
 	msl_bmap_modeset,		/* bmo_mode_chngf() */
 	msl_bmap_final_cleanup		/* bmo_final_cleanupf() */
diff -dru -x .git develop/slash2/mount_slash/ctl_cli.c next/slash2/mount_slash/ctl_cli.c
--- develop/slash2/mount_slash/ctl_cli.c	2018-03-27 11:22:08.817976227 -0400
+++ next/slash2/mount_slash/ctl_cli.c	2018-03-27 11:22:34.563717249 -0400
@@ -2,7 +2,6 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
  * Copyright 2007-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
@@ -1053,11 +1052,8 @@
 	psc_ctlparam_register("sys.resources", slctlparam_resources);
 	psc_ctlparam_register_simple("sys.uptime",
 	    slctlparam_uptime_get, NULL);
-
 	psc_ctlparam_register_simple("sys.version",
 	    slctlparam_version_get, NULL);
-	psc_ctlparam_register_simple("sys.rpc_version",
-	    slctlparam_rpc_version_get, NULL);
 
 	psc_ctlparam_register_var("sys.attr_timeout", PFLCTL_PARAMT_INT,
 	    PFLCTL_PARAMF_RDWR, &msl_attributes_timeout);
diff -dru -x .git develop/slash2/mount_slash/dircache.c next/slash2/mount_slash/dircache.c
--- develop/slash2/mount_slash/dircache.c	2018-03-27 11:22:08.819976127 -0400
+++ next/slash2/mount_slash/dircache.c	2018-03-27 11:22:34.564717200 -0400
@@ -2,7 +2,6 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
  * Copyright 2010-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
@@ -297,7 +296,7 @@
 }
 
 void
-dircache_trim(struct fidc_membh *d, int force)
+dircache_trim(struct fidc_membh *d)
 {
 	struct psc_hashbkt *b;
 	struct timeval now;
@@ -307,7 +306,7 @@
 	PFL_GETTIMEVAL(&now);
 	fci = fcmh_get_pri(d);
 	psclist_for_each_entry_safe(dce, tmp, &fci->fcid_entlist, dce_entry) {
-		if (!force && dce->dce_expire > now.tv_sec)
+		if (dce->dce_age + DCACHE_ENTRY_LIFETIME > now.tv_sec)
 			break;
 		fci->fcid_count--;
 		psc_assert(fci->fcid_count >= 0);
@@ -328,7 +327,7 @@
 
 void
 dircache_reg_ents(struct fidc_membh *d, struct dircache_page *p,
-    int nents, void *base, size_t size, int eof, int32_t lease)
+    int nents, void *base, size_t size, int eof)
 {
 	int i, rc;
 	off_t adj;
@@ -344,7 +343,7 @@
 
 	DIRCACHE_WRLOCK(d);
 
-	dircache_trim(d, 0);
+	dircache_trim(d);
 
 	fci = fcmh_get_pri(d);
 	/*
@@ -392,7 +391,7 @@
 		dce->dce_namelen = dirent->pfd_namelen;
 		dce->dce_flag = DIRCACHE_F_SHORT;
 		dce->dce_name = &dce->dce_short[0];
-		dce->dce_expire = now.tv_sec + lease;
+		dce->dce_age = now.tv_sec;
 		strncpy(dce->dce_name, dirent->pfd_name, dce->dce_namelen);
 		dce->dce_key = dircache_hash(dce->dce_pino, dce->dce_name, 
 		    dce->dce_namelen);
@@ -447,7 +446,7 @@
 		}
 		FCMH_LOCK(f);
 		OPSTAT_INCR("msl.readdir-fcmh");
-		slc_fcmh_setattr_locked(f, &e->sstb, lease);
+		slc_fcmh_setattr_locked(f, &e->sstb);
 
 #if 0
 		/*
@@ -467,8 +466,7 @@
 	p->dcp_nents = nents;
 	p->dcp_base = base;
 	p->dcp_size = size;
-	PFL_GETTIMEVAL(&now);
-	p->dcp_expire = now.tv_sec + lease;
+	PFL_GETPTIMESPEC(&p->dcp_local_tm);
 	p->dcp_flags |= eof ? DIRCACHEPGF_EOF : 0;
 	p->dcp_nextoff = dirent ? (off_t)dirent->pfd_off : p->dcp_off;
 	DIRCACHE_ULOCK(d);
@@ -487,7 +485,7 @@
 		return;
 
 	DIRCACHE_WRLOCK(d);
-	dircache_trim(d, 0);
+	dircache_trim(d);
 
 	len = strlen(name);
 	tmpdce.dce_name = (char *) name;
@@ -513,7 +511,7 @@
  * Add a name after a successful lookup.
  */
 void
-dircache_insert(struct fidc_membh *d, const char *name, uint64_t ino, int32_t lease)
+dircache_insert(struct fidc_membh *d, const char *name, uint64_t ino)
 {
 	int len;
 	struct timeval now;
@@ -527,7 +525,7 @@
 	fci = fcmh_get_pri(d);
 
 	DIRCACHE_WRLOCK(d);
-	dircache_trim(d, 0);
+	dircache_trim(d);
 
 	if (fci->fcid_count >= msl_max_namecache_per_directory) {
 		OPSTAT_INCR("dircache-limit");
@@ -555,7 +553,7 @@
 	/* fuse treats zero node ID as ENOENT */
 	psc_assert(ino);
 	dce->dce_ino = ino;
-	dce->dce_expire = now.tv_sec + lease;
+	dce->dce_age = now.tv_sec;
 	dce->dce_pino = fcmh_2_fid(d);
 	dce->dce_key = dircache_hash(dce->dce_pino, dce->dce_name, 
 	    dce->dce_namelen);
@@ -605,7 +603,7 @@
 
 	fci = fcmh_get_pri(d);
 	DIRCACHE_WRLOCK(d);
-	dircache_trim(d, 0);
+	dircache_trim(d);
 
 	len = strlen(name);
 	tmpdce.dce_name = (char *) name;
diff -dru -x .git develop/slash2/mount_slash/dircache.h next/slash2/mount_slash/dircache.h
--- develop/slash2/mount_slash/dircache.h	2018-03-27 11:22:08.819976127 -0400
+++ next/slash2/mount_slash/dircache.h	2018-03-27 11:22:34.565717151 -0400
@@ -2,7 +2,6 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
  * Copyright 2010-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
@@ -80,7 +79,7 @@
 	size_t			 dcp_size;	/* length of page (# dirents in page) */
 	off_t			 dcp_off;	/* getdents(2) 'offset' cookie of first dirent */
 	off_t			 dcp_nextoff;	/* next getdents(2) 'offset' cookie */
-	long			 dcp_expire;	/* expiration time */
+	struct pfl_timespec	 dcp_local_tm;	/* local clock when populated */
 	struct psc_listentry	 dcp_lentry;	/* chain on dci  */
 	void			*dcp_base;	/* pscfs_dirents */
 	slfgen_t		 dcp_dirgen;	/* directory generation; used to detect stale pages */
@@ -120,7 +119,7 @@
  * Determine if a page of dirents should be evicted.
  */
 #define DIRCACHEPG_EXPIRED(d, p, expire)				\
-	((expire) > (p)->dcp_expire ||					\
+	(timespeccmp((expire), &(p)->dcp_local_tm, >) ||		\
 	  (p)->dcp_dirgen != fcmh_2_gen(d))
 
 #define PFLOG_DIRCACHEPG(lvl, p, fmt, ...)				\
@@ -145,7 +144,7 @@
 	uint64_t		 dce_pino;
 	uint64_t		 dce_ino;
 	uint32_t		 dce_namelen;
-	long			 dce_expire;
+	long			 dce_age;
 	int			 dce_flag;
 	char			 dce_short[SL_MAX_SHORT_NAME];
 	char			*dce_name;	/* NOT null-terminated */
@@ -160,7 +159,7 @@
 void	dircache_init(struct fidc_membh *);
 void	dircache_purge(struct fidc_membh *);
 void	dircache_reg_ents(struct fidc_membh *, struct dircache_page *, 
-	    int, void *, size_t, int, int32_t);
+	    int, void *, size_t, int);
 void	dircache_walk_async(struct fidc_membh *, void (*)(
 	    struct dircache_page *, struct dircache_ent *, void *),
 	    void *, struct psc_compl *);
@@ -171,9 +170,8 @@
 int	dircache_ent_cmp(const void *, const void *);
 
 void	dircache_lookup(struct fidc_membh *, const char *, uint64_t *);
-void	dircache_insert(struct fidc_membh *, const char *, uint64_t, int32_t);
+void	dircache_insert(struct fidc_membh *, const char *, uint64_t);
 void	dircache_delete(struct fidc_membh *, const char *);
-void	dircache_trim(struct fidc_membh *, int);
 
 extern struct psc_hashtbl msl_namecache_hashtbl;
 
diff -dru -x .git develop/slash2/mount_slash/fidc_cli.c next/slash2/mount_slash/fidc_cli.c
--- develop/slash2/mount_slash/fidc_cli.c	2018-03-27 11:22:08.820976077 -0400
+++ next/slash2/mount_slash/fidc_cli.c	2018-03-27 11:22:34.566717102 -0400
@@ -2,7 +2,6 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
  * Copyright 2007-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
@@ -39,6 +38,7 @@
 #include "pfl/rsx.h"
 #include "pfl/str.h"
 #include "pfl/time.h"
+#include "pfl/treeutil.h"
 
 #include "bmap_cli.h"
 #include "cache_params.h"
@@ -49,16 +49,14 @@
 #include "mount_slash.h"
 #include "rpc_cli.h"
 
-
-extern struct psc_waitq		 msl_bmap_waitq;
+extern struct psc_waitq		msl_bmap_waitq;
 
 void
 slc_fcmh_invalidate_bmap(struct fidc_membh *f, __unusedx int wait)
 {
-	int i, wake = 0;
+	int i;
 	struct bmap *b;
 	struct psc_dynarray a = DYNARRAY_INIT;
-	struct bmap_cli_info *bci;
 
 	/*
 	 * Invalidate bmap lease so that we can renew it with 
@@ -87,20 +85,17 @@
 	pfl_rwlock_unlock(&f->fcmh_rwlock);
 
 	DYNARRAY_FOREACH(b, i, &a) {
-		OPSTAT_INCR("msl.bmap-destroy-biorqs");
-		msl_bmap_cache_rls(b);
-		BMAP_LOCK(b);
-		bmap_op_start_type(b, BMAP_OPCNT_WORK);
-		bmpc_biorqs_destroy_locked(b);
-		bci = bmap_2_bci(b);
-		lc_move2head(&msl_bmaptimeoutq, bci);
-		bmap_op_done_type(b, BMAP_OPCNT_WORK);
-	}
 
+		/* 
+		 * Hide the bmap from lookup to avoid waiting. This also hides
+		 * the bmap from slctlrep_getbmap() as well. So be careful.
+		 */
+		OPSTAT_INCR("msl.stash-bmap");
+		pfl_rwlock_wrlock(&f->fcmh_rwlock);
+		PSC_RB_XREMOVE(bmaptree, &f->fcmh_bmaptree, b);
+		pfl_rwlock_unlock(&f->fcmh_rwlock);
+	}
 	psc_dynarray_free(&a);
-
-	if (wake)
-		psc_waitq_wakeall(&msl_bmap_waitq);
 }
 
 /*
@@ -116,12 +111,11 @@
  *     (2) This function should only be used by a client.
  *
  * The current thinking is to store remote attributes in sstb.
- */
+ */ 
 void
 slc_fcmh_setattrf(struct fidc_membh *f, struct srt_stat *sstb,
-    int flags, int32_t timeout)
+    int flags)
 {
-	struct timeval now;
 	struct fcmh_cli_info *fci;
 
 	if (flags & FCMH_SETATTRF_HAVELOCK)
@@ -145,7 +139,9 @@
 			goto out;
 		}
 		if (fcmh_2_gen(f) < sstb->sst_gen) {
+#if 0
 			slc_fcmh_invalidate_bmap(f, 0);
+#endif
 			OPSTAT_INCR("msl.generation-forwards");
 			DEBUG_FCMH(PLL_DIAG, f, "attempt to set attr with "
 				"gen %"PRIu64" from old gen %"PRIu64,
@@ -204,8 +200,7 @@
 		dircache_init(f);
 
 	fci = fcmh_2_fci(f);
-	PFL_GETTIMEVAL(&now);
-	fci->fci_expire = now.tv_sec + timeout;
+	PFL_GETTIMEVAL(&fci->fci_age);
 
 	DEBUG_FCMH(PLL_DEBUG, f, "attr set");
 
diff -dru -x .git develop/slash2/mount_slash/fidc_cli.h next/slash2/mount_slash/fidc_cli.h
--- develop/slash2/mount_slash/fidc_cli.h	2018-03-27 11:22:08.821976028 -0400
+++ next/slash2/mount_slash/fidc_cli.h	2018-03-27 11:22:34.567717053 -0400
@@ -2,7 +2,6 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
  * Copyright 2007-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
@@ -69,8 +68,8 @@
  */
 struct fcmh_cli_info {
 	struct sl_resm			*fci_resm;
+	struct timeval			 fci_age;	/* attr update time */
 
-	long				 fci_expire;	/* attr expire time */
 	uint64_t                         fci_pino;	/* silly rename fields */
 	int                         	 fci_nopen;
 	char                            *fci_name;
@@ -127,13 +126,10 @@
 #define FCMH_SETATTRF_CLOBBER		(1 << 0)		/* overwrite any local updates (file size, etc) */
 #define FCMH_SETATTRF_HAVELOCK		(1 << 1)		/* fcmh spinlock doens't need to be obtained */
 
-void	slc_fcmh_setattrf(struct fidc_membh *, struct srt_stat *, int, int32_t);
-
-#define slc_fcmh_setattr(f, sstb, timeout) \
-	slc_fcmh_setattrf((f), (sstb), 0, (timeout))
+void	slc_fcmh_setattrf(struct fidc_membh *, struct srt_stat *, int);
 
-#define slc_fcmh_setattr_locked(f, sstb, timeout) \
-	slc_fcmh_setattrf((f), (sstb), FCMH_SETATTRF_HAVELOCK, (timeout))
+#define slc_fcmh_setattr(f, sstb)		slc_fcmh_setattrf((f), (sstb), 0)
+#define slc_fcmh_setattr_locked(f, sstb)	slc_fcmh_setattrf((f), (sstb), FCMH_SETATTRF_HAVELOCK)
 
 int	fcmh_checkcreds(struct fidc_membh *, struct pscfs_req *,
 	    const struct pscfs_creds *, int);
diff -dru -x .git develop/slash2/mount_slash/io.c next/slash2/mount_slash/io.c
--- develop/slash2/mount_slash/io.c	2018-03-27 11:22:08.823975931 -0400
+++ next/slash2/mount_slash/io.c	2018-03-27 11:22:34.568717004 -0400
@@ -2,7 +2,6 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
  * Copyright 2008-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
diff -dru -x .git develop/slash2/mount_slash/main.c next/slash2/mount_slash/main.c
--- develop/slash2/mount_slash/main.c	2018-03-27 11:22:08.825975834 -0400
+++ next/slash2/mount_slash/main.c	2018-03-27 11:22:34.772707029 -0400
@@ -2,7 +2,6 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
  * Copyright 2007-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
@@ -441,15 +440,14 @@
 	struct fidc_membh *c = NULL, *p = NULL;
 	struct slrpc_cservice *csvc = NULL;
 	struct pscrpc_request *rq = NULL;
-	struct srm_create_req *mq;
-	struct srm_create_rep *mp;
+	struct srm_create_rep *mp = NULL;
 	struct msl_fhent *mfh = NULL;
+	struct srm_create_req *mq;
 	struct fcmh_cli_info *fci = NULL;
 	struct bmap_cli_info *bci;
 	struct pscfs_creds pcr;
 	struct stat stb;
 	struct bmap *b;
-	int32_t lease = 0;
 
 	psc_assert(oflags & O_CREAT);
 
@@ -507,15 +505,14 @@
 	if (rc)
 		PFL_GOTOERR(out, rc);
 
-	lease = mp->lease;
-	slc_fcmh_setattr(p, &mp->pattr, lease);
+	slc_fcmh_setattr(p, &mp->pattr);
 
 	rc = msl_fcmh_get_fg(pfr, &mp->cattr.sst_fg, &c);
 	if (rc)
 		PFL_GOTOERR(out, rc);
 
 	msl_invalidate_readdir(p);
-	dircache_insert(p, name, fcmh_2_fid(c), lease);
+	dircache_insert(p, name, fcmh_2_fid(c));
 
 #if 0
 	if (oflags & O_APPEND) {
@@ -540,7 +537,7 @@
 
 	FCMH_LOCK(c);
 	slc_fcmh_setattrf(c, &mp->cattr, FCMH_SETATTRF_HAVELOCK |
-	    FCMH_SETATTRF_CLOBBER, msl_attributes_timeout);
+	    FCMH_SETATTRF_CLOBBER);
 	msl_internalize_stat(&c->fcmh_sstb, &stb);
 
 	fci = fcmh_2_fci(c);
@@ -613,8 +610,8 @@
 
  out:
 	pscfs_reply_create(pfr, mp ? mp->cattr.sst_fid : 0,
-	    mp ? mp->cattr.sst_gen : 0, (double)lease, &stb,
-	    (double)lease, mfh, rflags, rc);
+	    mp ? mp->cattr.sst_gen : 0, pscfs_entry_timeout, &stb,
+	    pscfs_attr_timeout, mfh, rflags, rc);
 
 	psclogs(rc ? PLL_WARN : PLL_DIAG, SLCSS_FSOP, "CREATE: pfid="SLPRI_FID" "
 	//psclogs(PLL_WARN, SLCSS_FSOP, "CREATE: pfid="SLPRI_FID" "
@@ -645,12 +642,12 @@
 
 	if (inum == SLFID_ROOT) {
 		PFL_GETTIMEVAL(&now);
-		if (timeval_diff(&now, &msl_statfs_root_last_failure) <
+		if (timeval_diff(&now, &msl_statfs_root_last_failure) < 
 		    1000000) {
 			OPSTAT_INCR("msl.open-root-reject");
 			rc = msl_statfs_root_last_errno;
 			PFL_GOTOERR(out2, rc);
-		}		
+		}
 	}
 
 	if (!msl_progallowed(pfr))
@@ -776,15 +773,12 @@
 	struct fcmh_cli_info *fci;
 	struct timeval now;
 	int rc = 0, timeout;
-	int32_t lease = 0;
 
-	fci = fcmh_2_fci(f);
 	/*
-	 * Special case to handle /$mountpoint/.slfidns/<fid>
+	 * Special case to handle accesses to
+	 * /$mountpoint/.slfidns/<fid>
 	 */
 	if (FID_GET_INUM(fcmh_2_fid(f)) == SLFID_NS) {
-		PFL_GETTIMEVAL(&now);
-		fci->fci_expire = now.tv_sec + 120;
 		f->fcmh_sstb.sst_mode = S_IFDIR | 0111;
 		f->fcmh_sstb.sst_nlink = 2;
 		f->fcmh_sstb.sst_size = 2;
@@ -793,12 +787,15 @@
 		return (0);
 	}
 
+	fci = fcmh_2_fci(f);
+
 	FCMH_LOCK(f);
 	fcmh_wait_locked(f, f->fcmh_flags & FCMH_GETTING_ATTRS);
 
 	if (f->fcmh_flags & FCMH_HAVE_ATTRS) {
 		PFL_GETTIMEVAL(&now);
-		if (now.tv_sec < fci->fci_expire) {
+		now.tv_sec -= msl_attributes_timeout;
+		if (now.tv_sec < fci->fci_age.tv_sec) {
 			DEBUG_FCMH(PLL_DIAG, f,
 			    "attrs retrieved from local cache");
 			FCMH_ULOCK(f);
@@ -806,6 +803,7 @@
 			return (0);
 		}
 		OPSTAT_INCR("attr-timeout");
+		f->fcmh_flags &= ~FCMH_HAVE_ATTRS;
 	}
 
 	/* Attrs have expired or do not exist. */
@@ -853,8 +851,7 @@
 	if (!rc && fcmh_2_fid(f) != mp->attr.sst_fid)
 		rc = EBADF;
 	if (!rc) {
-		lease = mp->lease;
-		slc_fcmh_setattr_locked(f, &mp->attr, lease);
+		slc_fcmh_setattr_locked(f, &mp->attr);
 		msl_fcmh_stash_xattrsize(f, mp->xattrsize);
 	}
 	f->fcmh_flags &= ~FCMH_GETTING_ATTRS;
@@ -875,9 +872,6 @@
 	struct pscfs_creds pcr;
 	struct fidc_membh *f;
 	struct stat stb;
-	long  timeout = 0;
-	struct timeval now;
-	struct fcmh_cli_info *fci;
 	int rc;
 
 
@@ -906,14 +900,10 @@
 	FCMH_LOCK(f);
 	msl_internalize_stat(&f->fcmh_sstb, &stb);
 
-	PFL_GETTIMEVAL(&now);
-	fci = fcmh_2_fci(f);
-	timeout = fci->fci_expire > now.tv_sec ? fci->fci_expire - now.tv_sec : 0;
-
  out:
 	if (f)
 		fcmh_op_done(f);
-	pscfs_reply_getattr(pfr, &stb, (double)timeout, rc);
+	pscfs_reply_getattr(pfr, &stb, pscfs_attr_timeout, rc);
 	DEBUG_STATBUF(rc ? PLL_INFO : PLL_DIAG, &stb, "getattr rc=%d",
 	    rc);
 }
@@ -930,7 +920,6 @@
 	struct pscfs_creds pcr;
 	struct stat stb;
 	int rc = 0;
-	int32_t lease = 0;
 
 	if (strlen(newname) == 0)
 		PFL_GOTOERR(out, rc = ENOENT);
@@ -990,22 +979,20 @@
 	if (rc)
 		PFL_GOTOERR(out, rc);
 
-	lease = mp->please;
-	slc_fcmh_setattr(p, &mp->pattr, lease);
+	slc_fcmh_setattr(p, &mp->pattr);
 
 	FCMH_LOCK(c);
-	lease = mp->clease;
-	slc_fcmh_setattr_locked(c, &mp->cattr, lease); 
+	slc_fcmh_setattr_locked(c, &mp->cattr);
 	msl_internalize_stat(&c->fcmh_sstb, &stb);
 	FCMH_ULOCK(c);
 
 	msl_invalidate_readdir(p);
-	dircache_insert(p, newname, fcmh_2_fid(c), lease);
+	dircache_insert(p, newname, fcmh_2_fid(c));
 
  out:
 	pscfs_reply_link(pfr, mp ? mp->cattr.sst_fid : 0,
-	    mp ? mp->cattr.sst_gen : 0, (double)lease, &stb,
-	    (double)lease, rc);
+	    mp ? mp->cattr.sst_gen : 0, pscfs_entry_timeout, &stb,
+	    pscfs_attr_timeout, rc);
 
 	psclogs(rc ? PLL_INFO : PLL_DIAG, SLCSS_FSOP, "LINK: cfid="SLPRI_FID" "
 	    "pfid="SLPRI_FID" name='%s' rc=%d",
@@ -1032,7 +1019,6 @@
 	struct pscfs_creds pcr;
 	struct stat stb;
 	int rc;
-	int32_t lease = 0;
 
 	if (strlen(name) == 0)
 		PFL_GOTOERR(out, rc = ENOENT);
@@ -1087,26 +1073,24 @@
 	if (rc)
 		PFL_GOTOERR(out, rc);
 
-	lease = mp->please;
-	slc_fcmh_setattr(p, &mp->pattr, lease);
+	slc_fcmh_setattr(p, &mp->pattr);
 
 	rc = msl_fcmh_get_fg(pfr, &mp->cattr.sst_fg, &c);
 	if (rc)
 		PFL_GOTOERR(out, rc);
 
 	msl_invalidate_readdir(p);
-	dircache_insert(p, name, fcmh_2_fid(c), lease);
+	dircache_insert(p, name, fcmh_2_fid(c));
 
 	FCMH_LOCK(c);
-	lease = mp->clease;
-	slc_fcmh_setattr_locked(c, &mp->cattr, lease);
+	slc_fcmh_setattr_locked(c, &mp->cattr);
 	msl_internalize_stat(&mp->cattr, &stb);
 	FCMH_ULOCK(c);
 
  out:
 	pscfs_reply_mkdir(pfr, mp ? mp->cattr.sst_fid : 0,
-	    mp ? mp->cattr.sst_gen : 0, (double)lease, &stb,
-	    (double)lease, rc);
+	    mp ? mp->cattr.sst_gen : 0, pscfs_entry_timeout, &stb,
+	    pscfs_attr_timeout, rc);
 
 	psclogs(rc ? PLL_INFO : PLL_DIAG, SLCSS_FSOP, "MKDIR: pfid="SLPRI_FID" "
 	    "cfid="SLPRI_FID" mode=%#o name='%s' rc=%d",
@@ -1133,7 +1117,6 @@
 	struct srm_lookup_req *mq;
 	struct srm_lookup_rep *mp;
 	int rc;
-	int32_t lease = 0;
 
  retry:
 	MSL_RMC_NEWREQ(p, csvc, SRMT_LOOKUP, rq, mq, mp, rc, 0);
@@ -1153,7 +1136,7 @@
 	if (rc)
 		PFL_GOTOERR(out, rc);
 
-	dircache_insert(p, name, mp->attr.sst_fg.fg_fid, lease);
+	dircache_insert(p, name, mp->attr.sst_fg.fg_fid);
 
 	/*
 	 * Add the inode to the cache first, otherwise pscfs may come to
@@ -1164,12 +1147,11 @@
 	if (rc)
 		PFL_GOTOERR(out, rc);
 
-	lease = mp->lease;
 	if (fgp)
 		*fgp = mp->attr.sst_fg;
 
 	FCMH_LOCK(f);
-	slc_fcmh_setattr_locked(f, &mp->attr, lease);
+	slc_fcmh_setattr_locked(f, &mp->attr);
 	msl_fcmh_stash_xattrsize(f, mp->xattrsize);
 
 	if (sstb)
@@ -1303,14 +1285,18 @@
 			goto rpc;
 		}
 		OPSTAT_INCR("msl.dircache-lookup-hit-ok");
+		FCMH_LOCK(c);
 		if (c->fcmh_flags & FCMH_HAVE_ATTRS) {
 			PFL_GETTIMEVAL(&now);
 			fci = fcmh_2_fci(c);
-			if (now.tv_sec < fci->fci_expire) {
+			now.tv_sec -= msl_attributes_timeout;
+			if (now.tv_sec < fci->fci_age.tv_sec) {
 				if (sstb)
 					*sstb = c->fcmh_sstb;
+				FCMH_ULOCK(c);
 				goto out;
 			}
+			c->fcmh_flags &= ~FCMH_HAVE_ATTRS;
 		}
 		fcmh_op_done(c);
 		c = NULL;
@@ -1436,7 +1422,6 @@
 	struct fcmh_cli_info *fci;
 	struct timeval tv;
 	struct psc_thread *me;
-	int32_t lease = 10;
 
 	MSL_RMC_NEWREQ(f, csvc, SRMT_RENAME, rq, mq, mp, rc, 0);
 	if (rc)
@@ -1471,7 +1456,7 @@
 
 	msl_invalidate_readdir(f);
 	dircache_delete(f, name);
-	dircache_insert(f, newname, fcmh_2_fid(c), lease);
+	dircache_insert(f, newname, fcmh_2_fid(c));
 	newname = NULL;
 
  out:
@@ -1501,7 +1486,6 @@
 	uint64_t inum;
 	int rc;
 	struct fcmh_cli_info *fci;
-	int32_t lease = 0;
 
 	if (strlen(name) == 0)
 		PFL_GOTOERR(out, rc = ENOENT);
@@ -1609,16 +1593,14 @@
 	if (rc)
 		PFL_GOTOERR(out, rc);
 
-	lease = mp->lease;
-	slc_fcmh_setattr(p, &mp->pattr, lease);
+	slc_fcmh_setattr(p, &mp->pattr);
 
 	if (sl_fcmh_lookup(mp->cattr.sst_fg.fg_fid, FGEN_ANY, 0, &c, pfr))
 		OPSTAT_INCR("msl.delete-skipped");
 	else {
 		FCMH_LOCK(c);
 		if (mp->valid) {
-			lease = mp->lease;
-			slc_fcmh_setattr_locked(c, &mp->cattr, lease);
+			slc_fcmh_setattr_locked(c, &mp->cattr);
 		} else {
 			c->fcmh_flags |= FCMH_DELETED;
 			OPSTAT_INCR("msl.delete-marked");
@@ -1669,12 +1651,11 @@
 	struct fidc_membh *p = NULL, *c = NULL;
 	struct slrpc_cservice *csvc = NULL;
 	struct pscrpc_request *rq = NULL;
-	struct srm_mknod_rep *mp;
-	struct srm_mknod_req *mq;
+	struct srm_mknod_rep *mp = NULL;
+	struct srm_mknod_req *mq = NULL;
 	struct pscfs_creds pcr;
 	struct stat stb;
 	int rc;
-	int32_t lease = 0;
 
 	if (!S_ISFIFO(mode) && !S_ISSOCK(mode))
 		PFL_GOTOERR(out, rc = ENOTSUP);
@@ -1726,26 +1707,24 @@
 	if (rc)
 		PFL_GOTOERR(out, rc);
 
-	lease = mp->please;
-	slc_fcmh_setattr(p, &mp->pattr, lease);
+	slc_fcmh_setattr(p, &mp->pattr);
 
 	rc = msl_fcmh_get_fg(pfr, &mp->cattr.sst_fg, &c);
 	if (rc)
 		PFL_GOTOERR(out, rc);
 
 	msl_invalidate_readdir(p);
-	dircache_insert(p, name, fcmh_2_fid(c), lease);
+	dircache_insert(p, name, fcmh_2_fid(c));
 
 	FCMH_LOCK(c);
-	lease = mp->clease;
-	slc_fcmh_setattr_locked(c, &mp->cattr, lease);
+	slc_fcmh_setattr_locked(c, &mp->cattr);
 	msl_internalize_stat(&mp->cattr, &stb);
 	FCMH_ULOCK(c);
 
  out:
 	pscfs_reply_mknod(pfr, mp ? mp->cattr.sst_fid : 0,
-	    mp ? mp->cattr.sst_gen : 0, (double)lease, &stb,
-	    (double)lease, rc);
+	    mp ? mp->cattr.sst_gen : 0, pscfs_entry_timeout, &stb,
+	    pscfs_attr_timeout, rc);
 
 	psclogs_diag(SLCSS_FSOP, "MKNOD: pfid="SLPRI_FID" "
 	    "cfid="SLPRI_FID" mode=%#o name='%s' rc=%d",
@@ -1765,7 +1744,7 @@
  */
 int
 msl_readdir_finish(struct fidc_membh *d, struct dircache_page *p,
-    int eof, int nents, int size, void *base, int32_t lease)
+    int eof, int nents, int size, void *base)
 {
 	/*
  	 * Stop name cache changes while we populating it.
@@ -1798,7 +1777,7 @@
 	d->fcmh_flags |= FCMH_BUSY;
 	FCMH_ULOCK(d);
 
-	dircache_reg_ents(d, p, nents, base, size, eof, lease);
+	dircache_reg_ents(d, p, nents, base, size, eof);
 
 	FCMH_LOCK(d);
 	d->fcmh_flags &= ~FCMH_BUSY;
@@ -1856,8 +1835,7 @@
 			PFL_GOTOERR(out, rc);
 	}
 	/* XXX: crash if I comment out the following line */
-	rc = msl_readdir_finish(d, p, mp->eof, mp->nents, 
-	    mp->size, dentbuf, mp->lease);
+	rc = msl_readdir_finish(d, p, mp->eof, mp->nents, mp->size, dentbuf);
 
  out:
 	DIRCACHE_WRLOCK(d);
@@ -1872,6 +1850,8 @@
 	psc_assert(p->dcp_flags & DIRCACHEPGF_LOADING);
 	p->dcp_flags &= ~(DIRCACHEPGF_LOADING | DIRCACHEPGF_ASYNC);
 
+	PFL_GETPTIMESPEC(&p->dcp_local_tm);
+
 	if (p->dcp_flags & DIRCACHEPGF_WAIT) {
 		p->dcp_flags &= ~DIRCACHEPGF_WAIT;
 		OPSTAT_INCR("msl.dircache-wakeup");
@@ -2001,19 +1981,19 @@
 	struct dircache_page *p, *np;
 	struct msl_fhent *mfh = data;
 	struct fidc_membh *d = NULL;
-	struct timeval now;
+	struct pfl_timespec now;
 	struct fcmh_cli_info *fci;
 	struct pscfs_dirent *pfd;
 	struct pscfs_creds pcr;
 	off_t raoff, poff, thisoff;
 	size_t len, tlen;
 
-	d = mfh->mfh_fcmh;
-	psc_assert(d);
-
 	if (off < 0 || size > 1024 * 1024)
 		PFL_GOTOERR(out, rc = EINVAL);
 
+	d = mfh->mfh_fcmh;
+	psc_assert(d);
+
 	if (!fcmh_isdir(d)) {
 		DEBUG_FCMH(PLL_ERROR, d, "readdir on a non-dir");
 		PFL_GOTOERR(out, rc = ENOTDIR);
@@ -2042,7 +2022,8 @@
 
 	raoff = 0;
 	issue = 1;
-	PFL_GETTIMEVAL(&now);
+	PFL_GETPTIMESPEC(&now);
+	now.tv_sec -= DIRCACHEPG_SOFT_TIMEO;
 
 	/*
 	 * XXX Large directories will page in lots of buffers so this
@@ -2058,7 +2039,6 @@
 		}
 		if (p->dcp_rc) {
 			rc = p->dcp_rc;
-			OPSTAT_INCR("msl.dircache-err");
 			dircache_free_page(d, p);
 			if (rc != -EAGAIN && 
 			    !slc_rpc_should_retry(pfr, &rc)) {
@@ -2067,8 +2047,7 @@
 			}
 			break;
 		}
-		if (DIRCACHEPG_EXPIRED(d, p, now.tv_sec)) {
-			OPSTAT_INCR("msl.dircache-exp");
+		if (DIRCACHEPG_EXPIRED(d, p, &now)) {
 			dircache_free_page(d, p);
 			continue;
 		}
@@ -2175,10 +2154,7 @@
 	struct srt_stat sstb;
 	struct sl_fidgen fg;
 	struct stat stb;
-	struct fcmh_cli_info *fci;
 	int rc;
-	struct timeval now;
-	int32_t lease;
 
 	memset(&sstb, 0, sizeof(sstb));
 
@@ -2195,22 +2171,9 @@
 	if (!S_ISDIR(stb.st_mode))
 		stb.st_blksize = MSL_FS_BLKSIZ;
 
-	if (!rc) {
-		if (c) {
-			PFL_GETTIMEVAL(&now);
-			fci = fcmh_2_fci(c);
-			lease = now.tv_sec - fci->fci_expire;
-			if (lease < 0) {
-				OPSTAT_INCR("msl.lookup-zero-lease");
-				lease = 0;
-			}
-		} else 
-			lease = pscfs_attr_timeout;
-	}
-
  out:
 	pscfs_reply_lookup(pfr, sstb.sst_fid, sstb.sst_gen,
-	    pscfs_entry_timeout, &stb, lease, rc);
+	    pscfs_entry_timeout, &stb, pscfs_attr_timeout, rc);
 	if (c)
 		fcmh_op_done(c);
 	if (p)
@@ -2418,7 +2381,7 @@
 	}
 
 	if (!rc)
-		slc_fcmh_setattrf(f, &mp->attr, setattrflags, msl_attributes_timeout);
+		slc_fcmh_setattrf(f, &mp->attr, setattrflags);
  out:
 	DEBUG_SSTB(rc ? PLL_WARN : PLL_DIAG, &f->fcmh_sstb,
 	    "attr flush; set=%#x rc=%d", to_set, rc);
@@ -2444,6 +2407,7 @@
 
 	FCMH_LOCK(f);
 	FCMH_WAIT_BUSY(f, 0);
+	fcmh_wait_locked(f, f->fcmh_flags & FCMH_CLI_TRUNC);
 
 	/*
 	 * Perhaps this checking should only be done on the mfh, with
@@ -2655,7 +2619,6 @@
 	struct pscfs_creds pcr;
 	struct iovec iov[2];
 	int sticky, rc;
-	int32_t lease = 0;
 
 	memset(&dstsstb, 0, sizeof(dstsstb));
 	srcfg.fg_fid = FID_ANY;
@@ -2797,16 +2760,16 @@
 		PFL_GOTOERR(out, rc);
 
 	/* refresh old parent attributes */
-	slc_fcmh_setattr(op, &mp->srr_opattr, mp->olease);
+	slc_fcmh_setattr(op, &mp->srr_opattr);
 
 	if (np != op)
 		/* refresh new parent attributes */
-		slc_fcmh_setattr(np, &mp->srr_npattr, mp->nlease);
+		slc_fcmh_setattr(np, &mp->srr_npattr);
 
 	/* refresh moved file's attributes */
 	if (mp->srr_cattr.sst_fid != FID_ANY &&
 	    msl_fcmh_load_fg(&mp->srr_cattr.sst_fg, &ch, pfr) == 0) {
-		slc_fcmh_setattr(ch, &mp->srr_cattr, msl_attributes_timeout);
+		slc_fcmh_setattr(ch, &mp->srr_cattr);
 		fcmh_op_done(ch);
 	}
 
@@ -2834,7 +2797,7 @@
 			ch->fcmh_flags |= FCMH_DELETED;
 			OPSTAT_INCR("msl.clobber");
 		}
-		slc_fcmh_setattr_locked(ch, &mp->srr_clattr, mp->clease);
+		slc_fcmh_setattr_locked(ch, &mp->srr_clattr);
 		fcmh_op_done(ch);
 	}
 
@@ -2846,12 +2809,9 @@
 
 	msl_invalidate_readdir(op);
 	dircache_delete(op, oldname); 
-	/*
- 	 * XXX child is NULL for a simple rename in the same directory!
- 	 */
 	if (child) {
 		msl_invalidate_readdir(np);
-		dircache_insert(np, newname, fcmh_2_fid(child), lease); 
+		dircache_insert(np, newname, fcmh_2_fid(child)); 
 	}
 
  out:
@@ -2977,14 +2937,13 @@
 {
 	struct fidc_membh *c = NULL, *p = NULL;
 	struct slrpc_cservice *csvc = NULL;
-	struct srm_symlink_req *mq;
 	struct srm_symlink_rep *mp = NULL;
 	struct pscrpc_request *rq = NULL;
+	struct srm_symlink_req *mq;
 	struct pscfs_creds pcr;
 	struct iovec iov;
 	struct stat stb;
 	int rc;
-	int32_t lease;
 
 	if (strlen(buf) == 0 || strlen(name) == 0)
 		PFL_GOTOERR(out, rc = ENOENT);
@@ -3038,22 +2997,19 @@
 	if (rc)
 		PFL_GOTOERR(out, rc);
 
-	lease = mp->please;
-	slc_fcmh_setattr(p, &mp->pattr, lease);
+	slc_fcmh_setattr(p, &mp->pattr);
 
 	rc = msl_fcmh_get_fg(pfr, &mp->cattr.sst_fg, &c);
 	if (rc)
 		PFL_GOTOERR(out, rc);
 
-	lease = mp->clease;
 	FCMH_LOCK(c);
-	slc_fcmh_setattr_locked(c, &mp->cattr, lease);
+	slc_fcmh_setattr_locked(c, &mp->cattr);
 	msl_internalize_stat(&mp->cattr, &stb);
 	FCMH_ULOCK(c);
 
-	lease = mp->please;
 	msl_invalidate_readdir(p);
-	dircache_insert(p, name, fcmh_2_fid(c), lease);
+	dircache_insert(p, name, fcmh_2_fid(c));
 
  out:
 	pscfs_reply_symlink(pfr, mp ? mp->cattr.sst_fid : 0,
@@ -3114,7 +3070,7 @@
     struct stat *stb, int to_set, void *data)
 {
 	int flush_mtime = 0, flush_size = 0, setattrflags = 0;
-	int i, rc = 0, unset_trunc = 0, getting_attrs = 0;
+	int i, rc = 0, force = 0, unset_trunc = 0, getting_attrs = 0, invalid = 0;
 	struct msl_dc_inv_entry_data mdie;
 	struct msl_fhent *mfh = data;
 	struct fidc_membh *c = NULL;
@@ -3134,6 +3090,7 @@
 
 	FCMH_LOCK(c);
 	FCMH_WAIT_BUSY(c, 0);
+	fcmh_wait_locked(c, c->fcmh_flags & FCMH_CLI_TRUNC);
 
 	/*
 	 * pscfs_reply_setattr() needs a fresh statbuf to refresh the
@@ -3243,8 +3200,16 @@
 		}
 	}
 
+	if (c->fcmh_flags & FCMH_CLI_DIRTY_DSIZE) {
+		flush_size = 1;
+		if (!(to_set & PSCFS_SETATTRF_DATASIZE)) {
+			force = 1;
+			to_set |= PSCFS_SETATTRF_DATASIZE;
+			stb->st_size = c->fcmh_sstb.sst_size;
+		}
+	}
+
 	if (to_set & PSCFS_SETATTRF_DATASIZE) {
-		fcmh_wait_locked(c, c->fcmh_flags & FCMH_CLI_TRUNC);
 		/*
 		 * Mark as busy against I/O on this and higher bmaps and
 		 * concurrent truncation requests util the MDS has
@@ -3263,27 +3228,19 @@
 		struct bmap *b;
 
 		if (!stb->st_size) {
-
-			/*
-			 * XXX we appear to have issues with race at sliod site
-			 * where reclaim/reopen race with I/O on a file with the
-			 * same generation number. Must audit the code carefully.
-			 *
-			 * While the deadlock issues are fixed now, we should look
-			 * deeper for the root causes.
-			 */
+			invalid = 1;
 			DEBUG_FCMH(PLL_DIAG, c, "full truncate, free bmaps");
 			OPSTAT_INCR("msl.truncate-full");
-			bmap_free_all_locked(c);
 		} else if (stb->st_size == (ssize_t)fcmh_2_fsz(c)) {
 			/*
 			 * No-op.  Don't send truncate request if the
 			 * sizes match.
 			 */
-			FCMH_ULOCK(c);
-			OPSTAT_INCR("msl.truncate-noop");
-			goto out;
-		} else {
+			if (!force) {
+				OPSTAT_INCR("msl.truncate-size-noop");
+				to_set &= ~PSCFS_SETATTRF_DATASIZE;
+			}
+		} else if (stb->st_size < (ssize_t)fcmh_2_fsz(c)) {
 			/*
 			 * A tricky case to handle: we might be called when 
 			 * a previous partial truncation is not fully completed 
@@ -3339,10 +3296,12 @@
 				msl_bmap_cache_rls(b);
 				bmap_biorq_waitempty(b);
 				bmap_op_done_type(b, BMAP_OPCNT_TRUNCWAIT);
+				OPSTAT_INCR("msl.truncate-expire-bmap-done");
 			}
 			psc_dynarray_free(&a);
 			FCMH_LOCK(c);
-		}
+		} else
+			OPSTAT_INCR("msl.truncate-extend");
 	}
 
 	/* We're obtaining the attributes now. */
@@ -3371,13 +3330,6 @@
 			    c->fcmh_sstb.sst_mtime_ns, stb);
 		}
 	}
-	if (c->fcmh_flags & FCMH_CLI_DIRTY_DSIZE) {
-		flush_size = 1;
-		if (!(to_set & PSCFS_SETATTRF_DATASIZE)) {
-			to_set |= PSCFS_SETATTRF_DATASIZE;
-			stb->st_size = c->fcmh_sstb.sst_size;
-		}
-	}
 	c->fcmh_flags &= ~FCMH_CLI_DIRTY_ATTRS;
 	FCMH_ULOCK(c);
 
@@ -3385,6 +3337,11 @@
 	if (to_set & (PSCFS_SETATTRF_MTIME | PSCFS_SETATTRF_DATASIZE))
 		setattrflags |= FCMH_SETATTRF_CLOBBER;
 
+	if (to_set == 0) {
+		FCMH_ULOCK(c);
+		goto out;
+	}
+
  retry:
 	rc = msl_setattr(c, to_set, &sstb, setattrflags);
 	if (rc && slc_rpc_should_retry(pfr, &rc))
@@ -3394,10 +3351,24 @@
 	if (c) {
 		FCMH_LOCK(c);
 		FCMH_UNBUSY(c, 0);
+
+		/*
+ 		 * For partial truncation, the generation number does not
+ 		 * change, we could keep the bmap beyond the truncation
+ 		 * point. But why not just start from scratch in case MDS
+ 		 * wants to assign a new IOS? Keep it simple.
+ 		 */
+		if (!rc && invalid) {
+			OPSTAT_INCR("msl.truncate-all");
+			msreadahead_cancel(c);
+			slc_fcmh_invalidate_bmap(c, 0);
+		}
+
 		if (unset_trunc) {
 			c->fcmh_flags &= ~FCMH_CLI_TRUNC;
 			fcmh_wake_locked(c);
 		}
+
 		if (rc && getting_attrs)
 			c->fcmh_flags &= ~FCMH_GETTING_ATTRS;
 		msl_internalize_stat(&c->fcmh_sstb, stb);
@@ -3734,8 +3705,9 @@
 		struct timeval now;
 
 		PFL_GETTIMEVAL(&now);
+		now.tv_sec -= msl_attributes_timeout;
 		fci = fcmh_2_fci(f);
-		if (now.tv_sec >= fci->fci_expire) {
+		if (now.tv_sec >= fci->fci_age.tv_sec) {
 			f->fcmh_flags &= ~FCMH_CLI_XATTR_INFO;
 		/* 05/08/2017: suspect crash site */
 		} else if (size == 0 && fci->fci_xattrsize != (uint32_t)-1) {
@@ -3925,9 +3897,10 @@
 		struct timeval now;
 
 		PFL_GETTIMEVAL(&now);
+		now.tv_sec -= msl_attributes_timeout;
 		fci = fcmh_2_fci(f);
 		locked = FCMH_RLOCK(f);
-		if (now.tv_sec < fci->fci_expire &&
+		if (now.tv_sec < fci->fci_age.tv_sec &&
 		    fci->fci_xattrsize == 0)
 			rc = ENODATA; // ENOATTR
 		FCMH_URLOCK(f, locked);
diff -dru -x .git develop/slash2/mount_slash/mount_slash.h next/slash2/mount_slash/mount_slash.h
--- develop/slash2/mount_slash/mount_slash.h	2018-03-27 11:22:08.826975785 -0400
+++ next/slash2/mount_slash/mount_slash.h	2018-03-27 11:22:34.773706980 -0400
@@ -2,7 +2,6 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
  * Copyright 2006-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
@@ -342,8 +341,6 @@
 void	 slc_setprefios(sl_ios_id_t);
 int	 msl_pages_fetch(struct bmpc_ioreq *);
 
-void	 msl_bmap_cache_rls(struct bmap *);
-
 struct pscfs_creds *
 	 slc_getfscreds(struct pscfs_req *, struct pscfs_creds *, int);
 
@@ -361,6 +358,10 @@
 void	 bmap_flushq_wake(int);
 void	 bmap_flush_resched(struct bmpc_ioreq *, int);
 
+void	 msreadahead_cancel(struct fidc_membh *);
+void	 slc_fcmh_invalidate_bmap(struct fidc_membh *, int);
+
+
 /* bmap flush modes (bmap_flushq_wake) */
 #define BMAPFLSH_RPCWAIT	(1 << 0)
 #define BMAPFLSH_EXPIRE		(1 << 1)
diff -dru -x .git develop/slash2/mount_slash/mount_slash.sh.8 next/slash2/mount_slash/mount_slash.sh.8
--- develop/slash2/mount_slash/mount_slash.sh.8	2018-03-27 11:22:08.827975736 -0400
+++ next/slash2/mount_slash/mount_slash.sh.8	2018-03-27 11:22:34.775706882 -0400
@@ -1,7 +1,7 @@
 .\" $Id$
 .\" %GPL_START_LICENSE%
 .\" ---------------------------------------------------------------------
-.\" Copyright 2016, Google, Inc.
+.\" Copyright 2018, Pittsburgh Supercomputing Center
 .\" All rights reserved.
 .\"
 .\" This program is free software; you can redistribute it and/or modify
diff -dru -x .git develop/slash2/mount_slash/pgcache.c next/slash2/mount_slash/pgcache.c
--- develop/slash2/mount_slash/pgcache.c	2018-03-27 11:22:08.828975687 -0400
+++ next/slash2/mount_slash/pgcache.c	2018-03-27 11:22:34.776706834 -0400
@@ -2,7 +2,6 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
  * Copyright 2009-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
@@ -566,6 +565,36 @@
 	}
 }
 
+void
+bmpc_biorqs_destroy_locked(struct bmap *b)
+{
+	struct psc_dynarray a = DYNARRAY_INIT;
+	struct bmpc_ioreq *r;
+	struct bmap_pagecache *bmpc;
+	int i;
+
+	BMAP_LOCK_ENSURE(b);
+
+	/*
+ 	 * To avoid double release of a ioreq.  This logic is protected by
+ 	 * BMAPF_SCHED and BMAP_LOCK.
+ 	 */
+	bmpc = bmap_2_bmpc(b);
+	RB_FOREACH(r, bmpc_biorq_tree, &bmpc->bmpc_biorqs)
+		psc_dynarray_add(&a, r);
+
+	BMAP_ULOCK(b);
+
+	msl_bmap_cache_rls(b);
+	DYNARRAY_FOREACH(r, i, &a) {
+		/* p ((struct pfl_opstat *)pfl_opstats.pda_items[68]).opst_name */
+		OPSTAT_INCR("msl.biorq-discard-destroy");
+		msl_biorq_release(r);
+	}
+	BMAP_LOCK(b);
+	psc_dynarray_free(&a);
+}
+
 #define	PAGE_RECLAIM_BATCH	1
 
 /* Called from psc_pool_reap() and msl_pgcache_reap() */
diff -dru -x .git develop/slash2/mount_slash/pgcache.h next/slash2/mount_slash/pgcache.h
--- develop/slash2/mount_slash/pgcache.h	2018-03-27 11:22:08.829975638 -0400
+++ next/slash2/mount_slash/pgcache.h	2018-03-27 11:22:34.777706786 -0400
@@ -2,7 +2,6 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
  * Copyright 2009-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
@@ -327,6 +326,8 @@
 
 extern struct psc_listcache	 bmpcLru;
 
+void   bmpc_biorqs_destroy_locked(struct bmap *);
+
 static __inline void
 bmpc_init(struct bmap_pagecache *bmpc)
 {
diff -dru -x .git develop/slash2/mount_slash/rcm.c next/slash2/mount_slash/rcm.c
--- develop/slash2/mount_slash/rcm.c	2018-03-27 11:22:08.831975540 -0400
+++ next/slash2/mount_slash/rcm.c	2018-03-27 11:22:34.778706737 -0400
@@ -2,7 +2,6 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
  * Copyright 2007-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
@@ -43,8 +42,6 @@
 #include "slconn.h"
 #include "slerr.h"
 
-extern struct psc_waitq                 msl_flush_attrq;
-
 struct msctl_replstq *
 mrsq_lookup(int id)
 {
@@ -275,89 +272,6 @@
  * @rq: request.
  */
 int
-msrcm_handle_file_cb(struct pscrpc_request *rq)
-{
-	struct srm_filecb_req *mq; 
-	struct srm_filecb_rep *mp; 
-	struct timeval now;
-
-	struct fcmh_cli_info *fci;
-	struct fidc_membh *f = NULL;
-
-	OPSTAT_INCR("msl.file-callback");
-
-	SL_RSX_ALLOCREP(rq, mq, mp);
-
-	mp->rc = sl_fcmh_peek_fg(&mq->fg, &f);
-	if (mp->rc)
-		PFL_GOTOERR(out, mp->rc);
-
-	/*
-	 * XXX Need to notify FUSE with invalidate_entry call.
-	 */ 	
-	fci = fcmh_get_pri(f);
-	FCMH_LOCK(f);
-	/*
- 	 * Expire attribues now and flush dirty attributes.
- 	 */
-	PFL_GETTIMEVAL(&now);
-	fci->fci_expire = now.tv_sec;
-	if (f->fcmh_flags & FCMH_CLI_DIRTY_QUEUE) {
-		OPSTAT_INCR("msl.callback-flush-attrs");
-		lc_move2head(&msl_attrtimeoutq, f);
-		psc_waitq_wakeone(&msl_flush_attrq);
-	}
-	if (fcmh_isdir(f)) {
-		if (psc_listhd_empty(&fci->fcid_entlist))
-			OPSTAT_INCR("msl.callback-invalidate-empty");
-		else {
-			OPSTAT_INCR("msl.callback-invalidte-dentry");
-			dircache_trim(f, 1);
-		}
-		dircache_purge(f);
-		goto out;
-	}
-
-#if 1
-
-	/*
- 	 * Callback only protect metadata, file data are protected
- 	 * by leases...
- 	 */
-	{
-		int i;
-		struct bmap *b;
-		struct psc_dynarray a = DYNARRAY_INIT;
-		/*
-		 * Use two loops to avoid a potential deadlock.
-		 */
-		pfl_rwlock_rdlock(&f->fcmh_rwlock);
-		RB_FOREACH(b, bmaptree, &f->fcmh_bmaptree) {
-			bmap_op_start_type(b, BMAP_OPCNT_WORK);
-			psc_dynarray_add(&a, b);
-		}
-		pfl_rwlock_unlock(&f->fcmh_rwlock);
-		DYNARRAY_FOREACH(b, i, &a) {
-			msl_bmap_cache_rls(b);
-			bmap_op_done_type(b, BMAP_OPCNT_WORK);
-		}
-		psc_dynarray_free(&a);
-	
-	}
-
-#endif
-
-out:
-	if (f)
-		fcmh_op_done(f);
-	return (0);
-}
-
-/*
- * Handle a BMAPDIO request for CLI from MDS.
- * @rq: request.
- */
-int
 msrcm_handle_bmapdio(struct pscrpc_request *rq)
 {
 	struct srm_bmap_dio_req *mq;
@@ -440,9 +354,6 @@
 	case SRMT_BMAPDIO:
 		rc = msrcm_handle_bmapdio(rq);
 		break;
-	case SRMT_FILECB:
-		rc = msrcm_handle_file_cb(rq);
-		break;
 	default:
 		psclog_errorx("unexpected opcode %d", rq->rq_reqmsg->opc);
 		rq->rq_status = -PFLERR_NOSYS;
Only in next/slash2/patch: invalidate-flush-race.patch
Only in next/slash2/patch: mysql2.patch
Only in next/slash2/patch: mysql.patch
Only in next/slash2/patch: pgcache.patch
diff -dru -x .git develop/slash2/share/authbuf_sign.c next/slash2/share/authbuf_sign.c
--- develop/slash2/share/authbuf_sign.c	2018-03-27 11:22:08.844974905 -0400
+++ next/slash2/share/authbuf_sign.c	2018-03-27 11:22:34.797705808 -0400
@@ -2,8 +2,7 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015, Google, Inc.
- * Copyright (c) 2009-2015, Pittsburgh Supercomputing Center (PSC).
+ * Copyright 2009-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -166,9 +165,6 @@
 	}
 
 	pscrpc_req_getprids(&sl_lnet_prids, rq, &self_prid, &peer_prid);
-	/*
- 	 * 01/29/2018: saf = 0x8000008031d400, signal 7 crash
- 	 */
 	if (saf->saf_secret.sas_src_nid != peer_prid.nid ||
 	    saf->saf_secret.sas_src_pid != peer_prid.pid ||
 	    saf->saf_secret.sas_dst_nid != self_prid.nid ||
diff -dru -x .git develop/slash2/share/bmap.c next/slash2/share/bmap.c
--- develop/slash2/share/bmap.c	2018-03-27 11:22:08.846974807 -0400
+++ next/slash2/share/bmap.c	2018-03-27 11:22:34.798705759 -0400
@@ -2,8 +2,7 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
- * Copyright 2008-2016, Pittsburgh Supercomputing Center
+ * Copyright 2008-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -71,9 +70,12 @@
 
 	DEBUG_BMAP(PLL_DIAG, b, "removing");
 
-	pfl_rwlock_wrlock(&f->fcmh_rwlock);
-	PSC_RB_XREMOVE(bmaptree, &f->fcmh_bmaptree, b);
-	pfl_rwlock_unlock(&f->fcmh_rwlock);
+	if (!(b->bcm_flags & BMAPF_DISCARD)) {
+		pfl_rwlock_wrlock(&f->fcmh_rwlock);
+		PSC_RB_XREMOVE(bmaptree, &f->fcmh_bmaptree, b);
+		pfl_rwlock_unlock(&f->fcmh_rwlock);
+	} else
+		OPSTAT_INCR("bmap-discard");
 
 	fcmh_op_done_type(f, FCMH_OPCNT_BMAP);
 	psc_pool_return(bmap_pool, b);
@@ -141,8 +143,11 @@
 			goto restart;
 		}
 
+		/* (gdb) p ((struct bmap_cli_info *) (b+1))->bci_bmpc.bmpc_tree */
+
 		if ((b->bcm_flags & BMAPF_TOFREE) ||
 		    (b->bcm_flags & BMAPF_DISCARD)) {
+
 			/*
 			 * This bmap is going away; wait for it so we
 			 * can reload it back.
@@ -321,12 +326,7 @@
 		rc = sl_bmap_ops.bmo_mode_chngf(b, rw, flags);
 		BMAP_LOCK(b);
 		if (rc == -ENOENT) {
-			b->bcm_flags &= ~(BMAPF_LOADED|BMAPF_MODECHNG);
-			/* 
-			 * (gdb) p ((struct pfl_opstat *) \
-			 *       pfl_opstats.pda_items[4]).opst_name
-			 *
-			 */
+			b->bcm_flags &= ~BMAPF_LOADED;
 			b->bcm_flags = (b->bcm_flags & ~BMAPF_RD) | BMAPF_WR;
 			OPSTAT_INCR("bmap-reload");
 			goto retrieve;
diff -dru -x .git develop/slash2/share/cfg_common.c next/slash2/share/cfg_common.c
--- develop/slash2/share/cfg_common.c	2018-03-27 11:22:08.847974758 -0400
+++ next/slash2/share/cfg_common.c	2018-03-27 11:22:34.799705710 -0400
@@ -2,8 +2,7 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
- * Copyright (c) 2006-2015, Pittsburgh Supercomputing Center (PSC).
+ * Copyright 2006-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
diff -dru -x .git develop/slash2/share/ctlcli_common.c next/slash2/share/ctlcli_common.c
--- develop/slash2/share/ctlcli_common.c	2018-03-27 11:22:08.848974709 -0400
+++ next/slash2/share/ctlcli_common.c	2018-03-27 11:22:34.800705661 -0400
@@ -2,8 +2,7 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
- * Copyright (c) 2009-2015, Pittsburgh Supercomputing Center (PSC).
+ * Copyright 2009-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -222,7 +221,7 @@
 	    scb->scb_flags & BMAPF_LOADING	? 'l' : '-',
 	    scb->scb_flags & BMAPF_DIO		? 'D' : '-',
 	    scb->scb_flags & BMAPF_TOFREE	? 'F' : '-',
-	    scb->scb_flags & BMAPF_DISCARD	? 'X' : '-',
+	    scb->scb_flags & BMAPF_DISCARD      ? 'X' : '-',
 	    scb->scb_flags & BMAPF_MODECHNG	? 'G' : '-',
 	    scb->scb_flags & BMAPF_WAITERS	? 'w' : '-',
 	    scb->scb_flags & BMAPF_BUSY		? 'B' : '-',
diff -dru -x .git develop/slash2/share/ctlsvr_common.c next/slash2/share/ctlsvr_common.c
--- develop/slash2/share/ctlsvr_common.c	2018-03-27 11:22:08.849974660 -0400
+++ next/slash2/share/ctlsvr_common.c	2018-03-27 11:22:34.801705612 -0400
@@ -2,8 +2,7 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
- * Copyright 2009-2016, Pittsburgh Supercomputing Center
+ * Copyright 2009-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -353,12 +352,6 @@
 }
 
 void
-slctlparam_rpc_version_get(char *val)
-{
-	snprintf(val, PCP_VALUE_MAX, "%d", SL_RPC_VERSION);
-}
-
-void
 slctlparam_uptime_get(char *val)
 {
 	struct timespec tv, delta;
diff -dru -x .git develop/slash2/share/priv.c next/slash2/share/priv.c
--- develop/slash2/share/priv.c	2018-03-27 11:22:08.851974562 -0400
+++ next/slash2/share/priv.c	2018-03-27 11:22:34.804705465 -0400
@@ -2,8 +2,7 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015, Google, Inc.
- * Copyright (c) 2010-2013, Pittsburgh Supercomputing Center (PSC).
+ * Copyright 2010-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
diff -dru -x .git develop/slash2/share/slerr.c next/slash2/share/slerr.c
--- develop/slash2/share/slerr.c	2018-03-27 11:22:08.853974464 -0400
+++ next/slash2/share/slerr.c	2018-03-27 11:22:34.806705367 -0400
@@ -2,8 +2,7 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
- * Copyright (c) 2009-2015, Pittsburgh Supercomputing Center (PSC).
+ * Copyright 2009-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
diff -dru -x .git develop/slash2/share/slutil.c next/slash2/share/slutil.c
--- develop/slash2/share/slutil.c	2018-03-27 11:22:08.854974415 -0400
+++ next/slash2/share/slutil.c	2018-03-27 11:22:34.806705367 -0400
@@ -2,8 +2,7 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015, Google, Inc.
- * Copyright (c) 2009-2015, Pittsburgh Supercomputing Center (PSC).
+ * Copyright 2009-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
diff -dru -x .git develop/slash2/slashd/bmap_mds.c next/slash2/slashd/bmap_mds.c
--- develop/slash2/slashd/bmap_mds.c	2018-03-27 11:22:08.858974219 -0400
+++ next/slash2/slashd/bmap_mds.c	2018-03-27 11:22:34.811705122 -0400
@@ -2,8 +2,7 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
- * Copyright 2006-2017, Pittsburgh Supercomputing Center
+ * Copyright 2006-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -543,7 +542,6 @@
 
 struct bmap_ops sl_bmap_ops = {
 	mds_bmap_init,			/* bmo_init_privatef() */
-	NULL,				/* bmo_reapf() */
 	mds_bmap_read,			/* bmo_retrievef() */
 	NULL,				/* bmo_mode_chngf() */
 	mds_bmap_destroy		/* bmo_final_cleanupf() */
diff -dru -x .git develop/slash2/slashd/bmap_mds.h next/slash2/slashd/bmap_mds.h
--- develop/slash2/slashd/bmap_mds.h	2018-03-27 11:22:08.859974170 -0400
+++ next/slash2/slashd/bmap_mds.h	2018-03-27 11:22:34.811705122 -0400
@@ -2,8 +2,7 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
- * Copyright 2006-2016, Pittsburgh Supercomputing Center
+ * Copyright 2006-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -143,8 +142,7 @@
 #define BTE_DEL			(1 << 1)
 #define BTE_REATTACH		(1 << 2)
 
-#define BMAP_TIMEO_MAX		240	/* Max/default bmap lease timeout */
-#define BMAP_TIMEO_MIN		40	/* Min bmap lease timeout */
+#define BMAP_TIMEO_MAX		240	/* Max bmap lease timeout */
 
 struct bmap_mds_lease {
 	uint64_t		  bml_seq;
diff -dru -x .git develop/slash2/slashd/ctl_mds.c next/slash2/slashd/ctl_mds.c
--- develop/slash2/slashd/ctl_mds.c	2018-03-27 11:22:08.861974072 -0400
+++ next/slash2/slashd/ctl_mds.c	2018-03-27 11:22:34.814704976 -0400
@@ -2,8 +2,7 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
- * Copyright 2006-2016, Pittsburgh Supercomputing Center
+ * Copyright 2006-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -234,7 +233,7 @@
 	/* pfl_odt_close(bml); */
 
 	/*
-	 * According to Google, sqlite3_close_v2 is not support in
+	 * According to Google, sqlite3_close_v2 is not support in 
 	 * SQLite until 3.7.15. Use sqlite3 --version to check the
 	 * version.
 	 */
@@ -574,12 +573,8 @@
 	psc_ctlparam_register("sys.resources", slctlparam_resources);
 	psc_ctlparam_register_simple("sys.uptime",
 	    slctlparam_uptime_get, NULL);
-
 	psc_ctlparam_register_simple("sys.version",
 	    slctlparam_version_get, NULL);
-	psc_ctlparam_register_simple("sys.rpc_version",
-	    slctlparam_rpc_version_get, NULL);
-
 	psc_ctlparam_register_var("sys.datadir", PFLCTL_PARAMT_STR, 0,
 	    (char *)sl_datadir);
 
diff -dru -x .git develop/slash2/slashd/fidc_mds.c next/slash2/slashd/fidc_mds.c
--- develop/slash2/slashd/fidc_mds.c	2018-03-27 11:22:08.863973974 -0400
+++ next/slash2/slashd/fidc_mds.c	2018-03-27 11:22:34.815704928 -0400
@@ -2,8 +2,7 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
- * Copyright 2007-2016, Pittsburgh Supercomputing Center
+ * Copyright 2007-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -125,7 +124,6 @@
 	}
 	fmi = fcmh_2_fmi(f);
 	memset(fmi, 0, sizeof(*fmi));
-	INIT_PSCLIST_HEAD(&fmi->fmi_callbacks);
 
 	rc = mdsio_lookup_slfid(vfsid, fcmh_2_fid(f), &rootcreds,
 	    &f->fcmh_sstb, &fcmh_2_mfid(f));
diff -dru -x .git develop/slash2/slashd/fidc_mds.h next/slash2/slashd/fidc_mds.h
--- develop/slash2/slashd/fidc_mds.h	2018-03-27 11:22:08.863973974 -0400
+++ next/slash2/slashd/fidc_mds.h	2018-03-27 11:22:34.815704928 -0400
@@ -2,8 +2,7 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
- * Copyright 2006-2015, Pittsburgh Supercomputing Center
+ * Copyright 2006-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -33,31 +32,6 @@
 #include "slashd.h"
 #include "up_sched_res.h"
 
-extern struct psc_poolmaster	 slm_callback_poolmaster;
-extern struct psc_poolmgr	*slm_callback_pool;
-
-struct fcmh_mds_callback {
-	/*
- 	 * The time period during which the MDS assumes that
- 	 * the client is still accessing the file.
- 	 */
-	int32_t			  fmc_expire;
-	lnet_process_id_t	  fmc_nidpid;
-	struct pscrpc_export	 *fmc_exp;
-	struct fcmh_mds_info	 *fmc_fmi;
-	struct psc_listentry	  fmc_lentry;
-	struct psc_listentry      fmc_timeo_lentry;
-};
-
-
-/*
- * List of fcmh callbacks.
- */
-struct fcmh_timeo_table {
-	psc_spinlock_t		 ftt_lock;
-	struct psc_lockedlist	ftt_callbacks;
-};
-
 /**
  * fcmh_mds_info - MDS-specific fcmh data.
  * @fmi_mfid - backing object MIO FID.  This is used to access the
@@ -70,7 +44,6 @@
 	struct slash_inode_handle fmi_inodeh;
 	mio_fid_t		  fmi_mfid;		/* backing object inum */
 	struct mio_fh		  fmi_mfh;		/* file handle */
-	struct psclist_head	  fmi_callbacks;
 	union {
 		struct {
 			/*
diff -dru -x .git develop/slash2/slashd/main_mds.c next/slash2/slashd/main_mds.c
--- develop/slash2/slashd/main_mds.c	2018-03-27 11:22:08.868973731 -0400
+++ next/slash2/slashd/main_mds.c	2018-03-27 11:22:34.821704634 -0400
@@ -2,8 +2,7 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
- * Copyright 2008-2016, Pittsburgh Supercomputing Center
+ * Copyright 2008-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -90,9 +89,6 @@
 
 struct psc_poolmaster	 slm_repl_status_poolmaster;
 
-struct psc_poolmaster	 slm_callback_poolmaster;
-struct psc_poolmgr	*slm_callback_pool;
-
 int
 psc_usklndthr_get_type(const char *namefmt)
 {
@@ -588,19 +584,6 @@
 	    2048, 0, NULL, "bmplease");
 	slm_bml_pool = psc_poolmaster_getmgr(&slm_bml_poolmaster);
 
-
-	/*
- 	 * Initialize file callback data structures.
- 	 */
-	psc_poolmaster_init(&slm_callback_poolmaster,
-	    struct fcmh_mds_callback, fmc_lentry, PPMF_AUTO, MDS_FIDCACHE_SIZE,
-	    MDS_FIDCACHE_SIZE, 0, NULL, "callback");
-	slm_callback_pool = psc_poolmaster_getmgr(&slm_callback_poolmaster);
-
-	INIT_SPINLOCK(&slm_fcmh_callbacks.ftt_lock);
-	pll_init(&slm_fcmh_callbacks.ftt_callbacks, struct fcmh_mds_callback,
-	    fmc_timeo_lentry, &slm_fcmh_callbacks.ftt_lock);
-
 	sl_nbrqset = pscrpc_prep_set();
 	pscrpc_nbreapthr_spawn(sl_nbrqset, SLMTHRT_NBRQ, 8,
 	    "slmnbrqthr");
diff -dru -x .git develop/slash2/slashd/mds_bmap_timeo.c next/slash2/slashd/mds_bmap_timeo.c
--- develop/slash2/slashd/mds_bmap_timeo.c	2018-03-27 11:22:08.871973585 -0400
+++ next/slash2/slashd/mds_bmap_timeo.c	2018-03-27 11:22:34.823704536 -0400
@@ -2,8 +2,7 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
- * Copyright 2010-2016, Pittsburgh Supercomputing Center
+ * Copyright 2010-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
diff -dru -x .git develop/slash2/slashd/mds.c next/slash2/slashd/mds.c
--- develop/slash2/slashd/mds.c	2018-03-27 11:22:08.870973634 -0400
+++ next/slash2/slashd/mds.c	2018-03-27 11:22:34.822704585 -0400
@@ -2,8 +2,7 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
- * Copyright 2006-2016, Pittsburgh Supercomputing Center
+ * Copyright 2006-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -54,14 +53,6 @@
 
 #include "zfs-fuse/zfs_slashlib.h"
 
-
-/*
- * Longer timeout values reduce RPC cost, but need more memory to
- * keep track of them.
- */
-int			slm_lease_timeout = BMAP_TIMEO_MAX;
-int			slm_callback_timeout = CALLBACK_TIMEO_MAX;
-
 #define	SLM_CBARG_SLOT_CSVC	0
 
 struct pfl_odt		*slm_bia_odt;
@@ -1359,7 +1350,7 @@
 
 	bml->bml_flags = flags;
 	bml->bml_start = time(NULL);
-	bml->bml_expire = bml->bml_start + slm_lease_timeout;
+	bml->bml_expire = bml->bml_start + BMAP_TIMEO_MAX;
 	bml->bml_bmi = bmap_2_bmi(b);
 
 	bml->bml_exp = e;
@@ -1437,7 +1428,7 @@
 	 * susceptible to gross changes in the system time.
 	 */
 	bml->bml_start = bia->bia_start;
-	bml->bml_expire = bml->bml_start + slm_lease_timeout;
+	bml->bml_expire = bml->bml_start + BMAP_TIMEO_MAX;
 	if (bml->bml_expire <= time(NULL))
 		OPSTAT_INCR("bmap-restart-expired");
 
diff -dru -x .git develop/slash2/slashd/mdsio_zfs.c next/slash2/slashd/mdsio_zfs.c
--- develop/slash2/slashd/mdsio_zfs.c	2018-03-27 11:22:08.872973536 -0400
+++ next/slash2/slashd/mdsio_zfs.c	2018-03-27 11:22:34.825704438 -0400
@@ -2,8 +2,7 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015, Google, Inc.
- * Copyright (c) 2008-2015, Pittsburgh Supercomputing Center (PSC).
+ * Copyright 2008-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
diff -dru -x .git develop/slash2/slashd/rmc.c next/slash2/slashd/rmc.c
--- develop/slash2/slashd/rmc.c	2018-03-27 11:22:08.880973144 -0400
+++ next/slash2/slashd/rmc.c	2018-03-27 11:22:34.832704095 -0400
@@ -2,8 +2,7 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
- * Copyright 2007-2016, Pittsburgh Supercomputing Center
+ * Copyright 2007-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -83,7 +82,6 @@
 struct timespec		slm_min_space_lastcheck;
 int			slm_min_space_reserve_pct = MIN_SPACE_RESERVE_PCT;
 	
-struct fcmh_timeo_table	slm_fcmh_callbacks;
 
 static void
 slm_root_attributes(struct srt_stat *attr)
@@ -210,135 +208,6 @@
 	return (0);
 }
 
-/*
- * Register our intention to access the file. If there are other clients 
- * interested in the same file, let them know.
- *
- * Note that a client doesn't ask for a callback explicitly. This way, we 
- * only incur overhead when more than one client is access the same file 
- * around the same time window.
- */
-int
-slm_fcmh_coherent_callback(struct fidc_membh *f, 
-    struct pscrpc_export *exp, int32_t *leasep)
-{
-	int32_t lease = 0;
-	int rc, count, found;
-	lnet_nid_t nid;
-	lnet_pid_t pid;
-	struct psc_listentry *tmp;
-	struct fcmh_mds_info *fmi;
-	struct srm_filecb_req *mq;
-	struct srm_filecb_rep *mp;
-	struct fcmh_mds_callback *cb, *found_cb;
-	struct pscrpc_request *rq = NULL;
-	struct slrpc_cservice *csvc = NULL;
-
-	pid = exp->exp_connection->c_peer.pid;
-	nid = exp->exp_connection->c_peer.nid;
-
-	rc = 0;
-	found = 0;
-	count = 0;
-
-
-#if 0
-	if (leasep)
-		*leasep = 30;
-	return (0);
-
-#else
-
-	fmi = fcmh_2_fmi(f);
-	FCMH_LOCK(f);
-	psclist_for_each(tmp, &fmi->fmi_callbacks) {
-		count++;
-		cb = psc_lentry_obj(tmp, struct fcmh_mds_callback, fmc_lentry);
-		if (cb->fmc_nidpid.nid == nid &&
-		    cb->fmc_nidpid.pid == pid) {
-			psc_assert(!found);
-			pll_remove(&slm_fcmh_callbacks.ftt_callbacks, cb);
-			found = 1;
-			found_cb = cb;
-		}
-	}
-	if (!count) {
-		lease = slm_callback_timeout;
-		OPSTAT_INCR("slm-new-callback");
-	}
-	if (count == 1 && found) {
-		lease = slm_callback_timeout;
-		OPSTAT_INCR("slm-renew-callback");
-	}
-	/*
- 	 * If the number of users goes from 1 to 2, send callbacks.
- 	 */
-	if (count == 1 && !found) {
-		csvc = slm_getclcsvc(cb->fmc_exp, 0);
-		/*
- 		 * Hit this when a client dies. Need more investigation.
- 		 */
-		if (!csvc) {
-			OPSTAT_INCR("slm-callback-skip");
-			goto next;
-		}
-		rc = SL_RSX_NEWREQ(csvc, SRMT_FILECB, rq, mq, mp);
-		if (rc)
-			goto next;
-		mq->fg = f->fcmh_fg;
-		rq->rq_async_args.pointer_arg[0] = csvc;
-		rc = SL_NBRQSET_ADD(csvc, rq);
-		if (rc)
-			goto next;
-		rq = NULL;
-		OPSTAT_INCR("slm-invoke-callback");
-	}
-
- next:
-
-	if (!found) {
-		cb = psc_pool_get(slm_callback_pool);
-		cb->fmc_nidpid.nid = nid;
-		cb->fmc_nidpid.pid = pid;
-		cb->fmc_exp = exp;
-		cb->fmc_fmi = fcmh_2_fmi(f);
-		INIT_PSC_LISTENTRY(&cb->fmc_lentry);
-		INIT_PSC_LISTENTRY(&cb->fmc_timeo_lentry);
-		fcmh_op_start_type(f, FCMH_OPCNT_CALLBACK);
-		psclist_add(&cb->fmc_lentry, &fmi->fmi_callbacks);
-	} else
-		cb = found_cb;
-	/*
- 	 * At this point, cb can be either a new callback or the one
- 	 * found on the list.  In either case, we update its
- 	 * expiration time, and add it to the end of the list.
- 	 *
- 	 * XXX we do this even if the lease time is zero.
- 	 */
-	cb->fmc_expire = time(NULL) + slm_callback_timeout;
-	pll_addtail(&slm_fcmh_callbacks.ftt_callbacks, cb);
-	FCMH_ULOCK(f);
-
-	/*
- 	 * Allow directory and its contents to be cached briefly.
- 	 * Some directories like root are naturally shared by
- 	 * many clients. If a client dies or goes away, its call
- 	 * back won't be cleared for a while. This makes sure we
- 	 * make progress regardless.
- 	 */
-	if (fcmh_isdir(f) && lease < 5)
-		lease = 5;
-
-	if (leasep)
-		*leasep = lease;
-	if (rq)
-		pscrpc_req_finished(rq);
-
-#endif
-
-	return (rc);
-}
-
 int
 slm_rmc_handle_getattr(struct pscrpc_request *rq)
 {
@@ -368,10 +237,9 @@
 	mp->xattrsize = mdsio_hasxattrs(vfsid, &rootcreds,
 	    fcmh_2_mfid(f));
 
-	mp->rc = slm_fcmh_coherent_callback(f, rq->rq_export, &mp->lease);
-
 	FCMH_LOCK(f);
 	mp->attr = f->fcmh_sstb;
+
  out:
 	if (f)
 		fcmh_op_done(f);
@@ -607,11 +475,6 @@
 	mdsio_fcmh_refreshattr(c, &mp->cattr);
 	mdsio_fcmh_refreshattr(p, &mp->pattr);
 
-	mp->rc = slm_fcmh_coherent_callback(p, rq->rq_export, &mp->please);
-	if (mp->rc)
-		PFL_GOTOERR(out, mp->rc);
-	mp->rc = slm_fcmh_coherent_callback(p, rq->rq_export, &mp->clease);
-
  out:
 	if (c)
 		fcmh_op_done(c);
@@ -624,7 +487,6 @@
 slm_rmc_handle_lookup(struct pscrpc_request *rq)
 {
 	struct fidc_membh *p = NULL;
-	struct fidc_membh *c = NULL;
 	struct srm_lookup_req *mq;
 	struct srm_lookup_rep *mp;
 	int vfsid;
@@ -706,22 +568,15 @@
 		}
 	}
 
-	mp->rc = -slm_fcmh_get(&mp->attr.sst_fg, &c);
-	if (mp->rc)
-		PFL_GOTOERR(out, mp->rc);
-	mp->rc = slm_fcmh_coherent_callback(c, rq->rq_export, &mp->lease);
-
  out:
-	if (c)
-		fcmh_op_done(c);
 	if (p)
 		fcmh_op_done(p);
 	return (0);
 }
 
 int
-slm_mkdir(int vfsid, struct pscrpc_request *rq, struct srm_mkdir_req *mq, 
-    struct srm_mkdir_rep *mp, int opflags, struct fidc_membh **dp)
+slm_mkdir(int vfsid, struct srm_mkdir_req *mq, struct srm_mkdir_rep *mp,
+    int opflags, struct fidc_membh **dp)
 {
 	struct fidc_membh *p = NULL, *c = NULL;
 	slfid_t fid = 0;
@@ -745,10 +600,6 @@
 	if (mp->rc)
 		PFL_GOTOERR(out, mp->rc);
 
-	mp->rc = slm_fcmh_coherent_callback(p, rq->rq_export, &mp->please);
-	if (mp->rc)
-		PFL_GOTOERR(out, mp->rc);
-
 	mds_reserve_slot(1);
 	mp->rc = -mdsio_mkdir(vfsid, fcmh_2_mfid(p), mq->name,
 	    &mq->sstb, 0, opflags, &mp->cattr, NULL, fid ? NULL :
@@ -763,10 +614,8 @@
 	 * Set new subdir's new files' default replication policy from
 	 * parent dir.
 	 */
-	if (mp->rc == 0 && slm_fcmh_get(&mp->cattr.sst_fg, &c) == 0) {
-		mp->rc = slm_fcmh_coherent_callback(p, rq->rq_export, &mp->clease);
+	if (mp->rc == 0 && slm_fcmh_get(&mp->cattr.sst_fg, &c) == 0)
 		slm_fcmh_endow(vfsid, p, c);
-	}
 
 	if (dp) {
 		if (mp->rc == -EEXIST &&
@@ -803,14 +652,13 @@
 	if (mp->rc)
 		return (0);
 
-	return (slm_mkdir(vfsid, rq, mq, mp, 0, NULL));
+	return (slm_mkdir(vfsid, mq, mp, 0, NULL));
 }
 
 int
 slm_rmc_handle_mknod(struct pscrpc_request *rq)
 {
 	struct fidc_membh *p = NULL;
-	struct fidc_membh *c = NULL;
 	struct srm_mknod_req *mq;
 	struct srm_mknod_rep *mp;
 	struct slash_creds cr;
@@ -835,19 +683,9 @@
 	mds_unreserve_slot(1);
 
 	mdsio_fcmh_refreshattr(p, &mp->pattr);
-	mp->rc = slm_fcmh_coherent_callback(p, rq->rq_export, &mp->please);
-	if (mp->rc)
-		PFL_GOTOERR(out, mp->rc);
-
-	mp->rc = -slm_fcmh_get(&mp->cattr.sst_fg, &c);
-	if (mp->rc)
-		PFL_GOTOERR(out, mp->rc);
-	mp->rc = slm_fcmh_coherent_callback(c, rq->rq_export, &mp->clease);
  out:
 	if (p)
 		fcmh_op_done(p);
-	if (c)
-		fcmh_op_done(c);
 	return (0);
 }
 
@@ -952,10 +790,6 @@
 	if (mp->rc)
 		PFL_GOTOERR(out, mp->rc);
 
-	mp->rc = slm_fcmh_coherent_callback(c, rq->rq_export, &mp->lease);
-	if (mp->rc)
-		PFL_GOTOERR(out, mp->rc);
-	
 	slm_fcmh_endow(vfsid, p, c);
 
 	/* obtain lease for first bmap as optimization */
@@ -1172,12 +1006,8 @@
 	} else {
 		mp->rc = slrpc_bulkserver(rq, BULK_PUT_SOURCE,
 		    SRMC_BULK_PORTAL, iov, nitems(iov));
-		if (mp->rc)
-			PFL_GOTOERR(out, mp->rc);
 	}
 
-	mp->rc = slm_fcmh_coherent_callback(f, rq->rq_export, &mp->lease);
-
  out:
 	if (f)
 		fcmh_op_done(f);
@@ -1295,20 +1125,12 @@
 	if (mp->rc)
 		PFL_GOTOERR(out, mp->rc);
 
-	mp->rc = slm_fcmh_coherent_callback(op, rq->rq_export, &mp->olease);
-	if (mp->rc)
-		PFL_GOTOERR(out, mp->rc);
-
 	if (SAMEFG(&mq->opfg, &mq->npfg)) {
 		np = op;
-		mp->nlease = mp->olease;
 	} else {
 		mp->rc = -slm_fcmh_get(&mq->npfg, &np);
 		if (mp->rc)
 			PFL_GOTOERR(out, mp->rc);
-		mp->rc = slm_fcmh_coherent_callback(op, rq->rq_export, &mp->nlease);
-		if (mp->rc)
-			PFL_GOTOERR(out, mp->rc);
 	}
 
 	/* if we get here, op and np must be owned by the current MDS */
@@ -1358,10 +1180,6 @@
 	} else
 		mp->srr_clattr.sst_fid = FID_ANY;
 
-	mp->rc = slm_fcmh_coherent_callback(op, rq->rq_export, &mp->clease);
-	if (mp->rc)
-		PFL_GOTOERR(out, mp->rc);
-
  out:
 	if (op)
 		fcmh_op_done(op);
@@ -1816,8 +1634,6 @@
 		    mq->name, &rootcreds, mdslog_namespace);
 	mds_unreserve_slot(1);
 
-	mp->rc = slm_fcmh_coherent_callback(p, rq->rq_export, &mp->lease);
-
  out:
 	if (mp->rc == 0) {
 		mdsio_fcmh_refreshattr(p, &mp->pattr);
diff -dru -x .git develop/slash2/slashd/rmi.c next/slash2/slashd/rmi.c
--- develop/slash2/slashd/rmi.c	2018-03-27 11:22:08.881973095 -0400
+++ next/slash2/slashd/rmi.c	2018-03-27 11:22:34.833704046 -0400
@@ -2,8 +2,7 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
- * Copyright 2008-2016, Pittsburgh Supercomputing Center
+ * Copyright 2008-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -240,7 +239,7 @@
 	sstb = mq->sstb;
 	mq->sstb.sst_uid = 0;
 	mq->sstb.sst_gid = 0;
-	rc = slm_mkdir(vfsid, rq, mq, mp, MDSIO_OPENCRF_NOMTIM, &d);
+	rc = slm_mkdir(vfsid, mq, mp, MDSIO_OPENCRF_NOMTIM, &d);
 	if (rc)
 		return (rc);
 	if (mp->rc && mp->rc != -EEXIST)
diff -dru -x .git develop/slash2/slashd/rmm.c next/slash2/slashd/rmm.c
--- develop/slash2/slashd/rmm.c	2018-03-27 11:22:08.882973046 -0400
+++ next/slash2/slashd/rmm.c	2018-03-27 11:22:34.834703997 -0400
@@ -2,8 +2,7 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
- * Copyright (c) 2008-2015, Pittsburgh Supercomputing Center (PSC).
+ * Copyright 2008-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
diff -dru -x .git develop/slash2/slashd/rpc_mds.h next/slash2/slashd/rpc_mds.h
--- develop/slash2/slashd/rpc_mds.h	2018-03-27 11:22:08.883972997 -0400
+++ next/slash2/slashd/rpc_mds.h	2018-03-27 11:22:34.835703949 -0400
@@ -2,8 +2,7 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
- * Copyright 2006-2016, Pittsburgh Supercomputing Center
+ * Copyright 2006-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -84,8 +83,8 @@
 	    struct sl_fidgen *, char *, char *, uint32_t,
 	    const struct slash_creds *, struct srt_stat *, int32_t);
 
-int	slm_mkdir(int, struct pscrpc_request *, struct srm_mkdir_req *, 
-	    struct srm_mkdir_rep *, int, struct fidc_membh **);
+int	slm_mkdir(int, struct srm_mkdir_req *, struct srm_mkdir_rep *,
+	    int, struct fidc_membh **);
 int	slm_symlink(struct pscrpc_request *, struct srm_symlink_req *,
 	    struct srm_symlink_rep *, int);
 
diff -dru -x .git develop/slash2/slashd/slashd.h next/slash2/slashd/slashd.h
--- develop/slash2/slashd/slashd.h	2018-03-27 11:22:08.885972899 -0400
+++ next/slash2/slashd/slashd.h	2018-03-27 11:22:34.837703852 -0400
@@ -2,8 +2,7 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
- * Copyright 2006-2016, Pittsburgh Supercomputing Center
+ * Copyright 2006-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -47,11 +46,6 @@
 
 struct slm_sth;
 struct bmap_mds_lease;
-extern int slm_lease_timeout;
-extern int slm_callback_timeout;
-
-#define CALLBACK_TIMEO_MAX             240     /* max/default callback timeout */
-#define CALLBACK_TIMEO_MIN             40      /* minimum callback timeout */
 
 extern sqlite3	*db_handle;
 
@@ -365,7 +359,6 @@
 extern int	mds_write_file(void *, void *, uint64_t, size_t *, off_t);
 extern int	mds_release_file(void *);
 
-extern struct fcmh_timeo_table	slm_fcmh_callbacks;
 
 /*
  * List of fault point that will be auto-registered on startup.
diff -dru -x .git develop/slash2/sliod/bmap_iod.c next/slash2/sliod/bmap_iod.c
--- develop/slash2/sliod/bmap_iod.c	2018-03-27 11:22:08.895972409 -0400
+++ next/slash2/sliod/bmap_iod.c	2018-03-27 11:22:34.848703313 -0400
@@ -2,8 +2,7 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
- * Copyright 2009-2016, Pittsburgh Supercomputing Center
+ * Copyright 2009-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -546,7 +545,6 @@
 
 struct bmap_ops sl_bmap_ops = {
 	iod_bmap_init,			/* bmo_init_privatef() */
-	NULL,				/* bmo_reapf() */
 	iod_bmap_retrieve,		/* bmo_retrievef() */
 	NULL,				/* bmo_mode_chngf() */
 	iod_bmap_finalcleanup		/* bmo_final_cleanupf() */
diff -dru -x .git develop/slash2/sliod/ctl_iod.c next/slash2/sliod/ctl_iod.c
--- develop/slash2/sliod/ctl_iod.c	2018-03-27 11:22:08.897972313 -0400
+++ next/slash2/sliod/ctl_iod.c	2018-03-27 11:22:34.850703215 -0400
@@ -2,8 +2,7 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
- * Copyright 2006-2016, Pittsburgh Supercomputing Center
+ * Copyright 2006-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -631,12 +630,8 @@
 
 	psc_ctlparam_register_simple("sys.uptime",
 	    slctlparam_uptime_get, NULL);
-
 	psc_ctlparam_register_simple("sys.version",
 	    slctlparam_version_get, NULL);
-	psc_ctlparam_register_simple("sys.rpc_version",
-	    slctlparam_rpc_version_get, NULL);
-
 	psc_ctlparam_register_var("sys.datadir", PFLCTL_PARAMT_STR, 0,
 	    (char *)sl_datadir);
 
diff -dru -x .git develop/slash2/sliod/ctl_iod.h next/slash2/sliod/ctl_iod.h
--- develop/slash2/sliod/ctl_iod.h	2018-03-27 11:22:08.898972264 -0400
+++ next/slash2/sliod/ctl_iod.h	2018-03-27 11:22:34.850703215 -0400
@@ -2,8 +2,7 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015, Google, Inc.
- * Copyright (c) 2006-2015, Pittsburgh Supercomputing Center (PSC).
+ * Copyright 2006-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
diff -dru -x .git develop/slash2/sliod/ric.c next/slash2/sliod/ric.c
--- develop/slash2/sliod/ric.c	2018-03-27 11:22:08.902972069 -0400
+++ next/slash2/sliod/ric.c	2018-03-27 11:22:34.855702972 -0400
@@ -2,8 +2,7 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
- * Copyright 2008-2016, Pittsburgh Supercomputing Center
+ * Copyright 2008-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -186,7 +185,6 @@
 		f->fcmh_flags |= FCMH_IOD_UPDATEFILE;
 		fcmh_op_start_type(f, FCMH_OPCNT_UPDATE);
 	} else {
-		/* XXX don't move if we have accumulate many writes */
 		OPSTAT_INCR("fcmh-update-requeue");
 		lc_move2tail(&sli_fcmh_update, fii);
 	}
@@ -646,10 +644,6 @@
 	char buf[PSCRPC_NIDSTR_SIZE];
 
 	if (rq->rq_reqmsg->opc != SRMT_CONNECT) {
-		/*
-		 * 01/22/2018: At 45116, rq->rq_export is NULL, triggers
- 		 * signal 11, Segmentation fault.
- 		 */
 		EXPORT_LOCK(rq->rq_export);
 		if (rq->rq_export->exp_private == NULL)
 			rc = -PFLERR_NOTCONN;
diff -dru -x .git develop/slash2/sliod/slvr_worker.c next/slash2/sliod/slvr_worker.c
--- develop/slash2/sliod/slvr_worker.c	2018-03-27 11:22:08.913971530 -0400
+++ next/slash2/sliod/slvr_worker.c	2018-03-27 11:22:34.865702482 -0400
@@ -2,7 +2,6 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
  * Copyright 2006-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
@@ -289,12 +288,6 @@
 			goto again; 
 		}
 
-		/*
-		 * 01/30/2018:
-		 *
-		 * At 45127, we crash in pscrpc_prep_req_pool() because
-		 * csvc->csvc_import is somehow NULL. csvc_lasterrno = -110.
-		 */
 		rc = SL_RSX_NEWREQ(csvc, SRMT_UPDATEFILE, rq, mq, mp);
 		if (rc)
 			goto out;
diff -dru -x .git develop/slash2/tests/smoketest/smoketest.c next/slash2/tests/smoketest/smoketest.c
--- develop/slash2/tests/smoketest/smoketest.c	2018-03-27 11:22:08.944970014 -0400
+++ next/slash2/tests/smoketest/smoketest.c	2018-03-27 11:22:34.898700869 -0400
@@ -2,8 +2,7 @@
 /*
  * %GPL_START_LICENSE%
  * ---------------------------------------------------------------------
- * Copyright 2015-2016, Google, Inc.
- * Copyright 2010-2016, Pittsburgh Supercomputing Center
+ * Copyright 2010-2018, Pittsburgh Supercomputing Center
  * All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
@@ -146,44 +145,6 @@
 
 }
 
-/* written to verify a dircache bug fix */
-int
-test_longname(void)
-{
-	int fd, rc;
-	char buf[1234];
-
-	char *tmpname1 = ".xfc.bbbbbbbb.new-12345566777777777777.xxxxx.xxxxx.---------bbbbbbbbbbbbbbbbbbbbbb.4356";
-	char *tmpname2 = "......111111111111111111.00000000000000000000000.ghghghghghhghhgh";
-
-	fd = open(tmpname1, O_CREAT|O_RDWR, S_IRWXU);
-	if (fd < 0) {
-		printf("Fail to create file %s, errno = %d at line %d!\n", tmpname1, errno, __LINE__);
-		return (1);
-	}
-	rc = write(fd, buf, 1234);
-	if (rc != 1234) {
-		printf("Fail to write file %s, errno = %d at line %d!\n", tmpname1, errno, __LINE__);
-		return (1);
-	}
-	rc = close(fd);
-	if (rc < 0) {
-		printf("Fail to close file %s, errno = %d at line %d!\n", tmpname1, errno, __LINE__);
-		return (1);
-	}
-	rc = rename(tmpname1, tmpname2);
-	if (rc) {
-		printf("Fail to rename file %s, errno = %d at line %d!\n", tmpname1, errno, __LINE__);
-		return (1);
-	}
-	rc = unlink(tmpname2);
-	if (rc) {
-		printf("Fail to remove file %s, errno = %d at line %d!\n", tmpname2, errno, __LINE__);
-		return (1);
-	}
-	return (0);
-}
-
 /*
  * See if we coalesce I/O requests properly.
  */
@@ -643,10 +604,6 @@
 		test_rename
 	},
 	{
-		"Test using a very long name to create/rename/unlink a file",
-		test_longname
-	},
-	{
 		"Random 8-byte writes at random offsets to simulate FUSE I/O",
 		test_random
 	},
diff -dru -x .git develop/slash2/TODO next/slash2/TODO
--- develop/slash2/TODO	2018-03-27 11:22:08.558988889 -0400
+++ next/slash2/TODO	2018-03-27 11:22:34.505720085 -0400
@@ -5492,38 +5492,6 @@
 	worker[1] Trying to dump core for [mysqld.2 - pid: 27495, winpid: 27495]
 	rpl.rpl_semi_sync_group_commit_deadlock 'mix' [ fail ]  timeout after 900 seconds
 
-	02/27/2018:
-
-	
-	Could not execute 'check-warnings' for testcase 'rpl.rpl_semi_sync_deadlock' (res: 1):
-	mysqltest: Could not open connection 'default' after 500 attempts: 2002 Can't connect to \
-	local MySQL server through socket '/tmp/mysql.sock' (2)
-
-
-	02/28/2018
-	----------
-
-	$ tar xvf ~/mysql-boost-5.7.17.tar.gz
-	$ cmake -DWITH_BOOST=boost/boost_1_59_0 .
-	$ make
-	$ cd mysql-test/
-	$ time ./mysql-test-run --big-test --skip-test=federated
-
-	rpl.rpl_sequential 'mix'                 [ fail ]
-        Test ended at 2018-02-28 16:20:22
-
-	CURRENT_TEST: rpl.rpl_sequential
-	mysqltest: In included file ./include/wait_condition.inc at line 49:
-	included from ./include/wait_condition_or_abort.inc at line 25:
-	included from ./extra/rpl_tests/rpl_parallel_load.test at line 188:
-	included from /zzh-slash2/zhihui/mysql-5.7.17/mysql-test/suite/rpl/t/rpl_sequential.test at line 21:
-	At line 49: Query 'SELECT count(*)+sleep(1) = 5 FROM test0.benchmark' didn't return a result set
-
-	Only  518  of 5001 completed.
-	mysql-test-run: *** ERROR: Not all tests completed
-	zhihui@zebes: /zzh-slash2/zhihui/mysql-5.7.17/mysql-test$
-
-
 01/13/2017
 ----------
 
@@ -6082,166 +6050,3 @@
 
 * FUSE readdirplus
 
-01/22/2018
-----------
-
-A signal 7 stack:
-
-(gdb) bt
-#0  0x000000000040c6f0 in pthread_getspecific@plt ()
-#1  0x00000000004a81cd in pscthr_get_canfail () at /opt/packages/slash2/cli/p/pfl/thread.c:175
-#2  0x00000000004aef09 in pscthr_get_callerinfo () at /opt/packages/slash2/cli/p/pfl/thread.c:545
-#3  0x00000000004b1e6b in _pfl_callerinfo_get (fn=0x4bf1b0 "/opt/packages/slash2/cli/p/pfl/waitq.c", 
-    func=0x4bf380 <__func__.6882> "_psc_waitq_waitabs", lineno=128, subsys=0) at /opt/packages/slash2/cli/p/pfl/pfl.h:124
-#4  0x00000000004b272f in _psc_waitq_waitabs (q=0x7febac3cd670, type=PFL_LOCKPRIMT_SPIN, lockp=0x0, abstime=0x7feb1affae10)
-    at /opt/packages/slash2/cli/p/pfl/waitq.c:128
-#5  0x00007febb2987baf in pscrpcthr_main (thr=0x7febac519250) at /opt/packages/slash2/cli/p/pfl/service.c:734
-#6  0x00000000004a9094 in _pscthr_begin (arg=0x7febc062a110) at /opt/packages/slash2/cli/p/pfl/thread.c:302
-#7  0x00007febc1c5edc5 in start_thread () from /lib64/libpthread.so.0
-#8  0x00007febc198d76d in clone () from /lib64/libc.so.6
-(gdb) up
-#1  0x00000000004a81cd in pscthr_get_canfail () at /opt/packages/slash2/cli/p/pfl/thread.c:175
-175		return (pthread_getspecific(psc_thrkey));
-(gdb) p psc_thrkey
-$3 = 0
-
-01/26/2018
-----------
-
-With 10+ iozone -a in the background, ls -al saw ?? attributes and self build returns 2.
-
-02/01/2018
-----------
-
-Make the slash2 log file as text file so that I can grep.
-
-The following patch solve the problem, but mount client hangs:
-
-diff --git a/pfl/log.c b/pfl/log.c
-index a37bfd3..2955882 100644
---- a/pfl/log.c
-+++ b/pfl/log.c
-@@ -228,7 +228,9 @@ psc_log_init(void)
- 	char *p;
- 
- 	p = getenv("PSC_LOG_FILE");
--	if (p && psc_log_setfn(p, "w"))
-+	if (!p)
-+		return;
-+	if (psc_log_setfn(p, "w"))
- 		errx(1, "%s", p);
- 
- 	p = getenv("PSC_LOG_FORMAT");
-diff --git a/wokfs/wokctl/wokctl.c b/wokfs/wokctl/wokctl.c
-index 4351ec7..19f32b8 100644
---- a/wokfs/wokctl/wokctl.c
-+++ b/wokfs/wokctl/wokctl.c
-@@ -188,6 +188,14 @@ struct psc_ctlopt opts[] = {
- int
- main(int argc, char *argv[])
- {
-+	int i;
-+	unsetenv("PSC_LOG_FILE");
-+
-+	fprintf(stderr, "wokctl arguments: ");
-+	for (i = 0; i < argc; i++)
-+		fprintf(stderr, "%s ", argv[i]);
-+	fprintf(stderr, "\n");
-+	
- 	pfl_init();
- 	psc_ctlcli_main(PATH_CTLSOCK, argc, argv, opts, nitems(opts));
- 	exit(0);
-
-02/02/2018
-----------
-
-Investigate smoke test state:
-
-bash-4.2# ./smoketest /zzh-slash2/zhihui
-smoketest: seed = 123456, workdir = /zzh-slash2/zhihui/35923
-Running test 1: Basic file/directory creations and deletions...
-Running test 2: Create a file with the name that has just been renamed...
-Running test 3: Random 8-byte writes at random offsets to simulate FUSE I/O...
-
-Running test 4: A non-owner changes the owner/group of a file to 65535:65535...
-Fail to chown file test-chmod.dat, errno = 1 at line 299!
-Running test 5: Test basic link support...
-Fail to create file test-link.dat, errno = 13 at line 324!
-Running test 6: Test basic truncate support...
-Fail to create file test-truncate.dat, errno = 13 at line 372!
-Running test 7: Test basic open support...
-Fail to create file test-open.dat, errno = 13 at line 426!
-Running test 8: Test basic large file I/O...
-Error opening file large-file-test.dat for writing at line 523.
-Total number of tests = 8, number of successes = 3
-
-
-02/08/2018
-----------
-
-On Thu, Feb 08, 2018 at 04:37:43PM -0500, Jason F Sommerfield wrote:
-
-> When doing an ls, I get errors that I can't view directories and them an
-> presented with the directories--which seems inconsistent.  Presumably I
-> should get the error and not be able to see them or not get an error and
-> be able to see them.
-
-Technically it is not showing which specific operation is causing an error.  I
-have a feeling it is a noncritical operation, set as getxattr.  Could you post
-strace output?
-
-> [root@vm072 vm072.mount_wokfs]# ls -l /pghbio/
-> ls: /pghbio/mapfile_testing: Permission denied
-> drwxr-x---  4 kar     pscstaff 22 Jan 22 20:56 mapfile_testing
-
-
-02/12/2018
-----------
-
-[zhihui@r517 ~]$ msctl-pylon2 -sP
-mem-pool     flag    #free     #use    total    %use    min    max thrsh     #shrnx #em #wa
-===========================================================================================
-asyncrq       A--       64        0       64      0%     64  <inf>    80          0   0   0
-biorq         A--     1024        0     1024      0%   1024  <inf>    80   24286918   0   0
-bmap          A--      784      161      945  17.04%     64  <inf>    80      54733   0   0
-bmpce         A--        0   652619   652619    100%    512 4194304    80     142009   0   0
-bwc           A--       80        0       80      0%     64  <inf>    80    1937880   0   0
-csvc          A--        1       65       66  98.48%     64  <inf>    80          0   0   0
-dircachent    A--     2047        1     2048   0.05%   2048  <inf>    80          0   0   0
-
-02/28/2018
-----------
-
-Make handling of 501 and 511 errors more robust.
-
-03/12/2018
-----------
-
-[zhihui@mds run]$ /usr/local/psc/sbin/slmctl -S slashd.mds.sock -s repl 
-resource                         ingress-pending  egress-pending    ingress-aggr     egress-aggr
-================================================================================================
-sbb1s0@PSC                                     0            5.5G               0          789.8G 
-sbb1s1@PSC                                     0            4.1G               0          687.3G 
-sbb1s2@PSC                                     0            4.3G               0          835.4G 
-sbb1s3@PSC                                     0            6.3G               0          746.4G 
-sbb1s4@PSC                                     0            4.1G               0          805.1G 
-sbb1s5@PSC                                     0            4.3G               0          796.3G 
-sbb1s6@PSC                                     0            6.0G               0          843.8G 
-sbb1s7@PSC                                     0            4.1G               0          791.6G 
-sbb2s0@PSC                                  8.8G               0          796.4G            3.9G
-sbb2s1@PSC                                  9.1G               0          796.4G            4.0G
-sbb2s2@PSC                                  7.5G               0          796.4G            5.4G
-sbb2s3@PSC                                  5.2G               0          796.4G            4.6G
-sbb2s4@PSC                                  3.5G               0          796.4G            5.8G
-sbb2s5@PSC                                  3.2G               0          796.4G            4.2G
-sbb2s6@PSC                                990.0M               0          796.2G            5.6G
-sbb2s7@PSC                                810.0M          270.0M          791.6G           37.2G 
-
-                                        we should get rid of pending number if we can't replicate
-
-Also, make repl-add no-op if the target is already VALID.
-
-03/20/2018
-----------
-
-Track per IOS number of outstanding leases (read and write), and total leases.
Only in next: slash2-build.sh
Only in next: slash2-merge.sh
Only in next: slash2-readme.txt
Only in next: slash2-test.txt
